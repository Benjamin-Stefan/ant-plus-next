{"version":3,"file":"index.mjs","sources":["../src/types/constants.ts","../src/utils/messages.ts","../src/core/driver/nodeUSBDriver.ts","../src/core/nodeUsbSticks.ts","../src/core/driver/usbDriverUtils.ts","../src/core/driver/webUSBDriver.ts","../src/core/webUsbStick.ts","../src/utils/customPolyfills.ts","../src/sensors/baseSensor.ts","../src/sensors/heartRate/heartRateUtils.ts","../src/sensors/heartRate/heartRateSensorState.ts","../src/sensors/heartRate/heartRateScanState.ts","../src/sensors/antPlusBaseSensor.ts","../src/sensors/antPlusSensor.ts","../src/sensors/heartRate/heartRateSensor.ts","../src/sensors/antPlusScanner.ts","../src/sensors/heartRate/heartRateScanner.ts","../src/sensors/strideSpeedDistance/strideSpeedDistanceUtils.ts","../src/sensors/strideSpeedDistance/strideSpeedDistanceSensorState.ts","../src/sensors/strideSpeedDistance/strideSpeedDistanceScanState.ts","../src/sensors/strideSpeedDistance/strideSpeedDistanceSensor.ts","../src/sensors/strideSpeedDistance/strideSpeedDistanceScanner.ts","../src/sensors/speedCadence/speedCadenceUtils.ts","../src/sensors/speedCadence/speedCadenceSensorState.ts","../src/sensors/speedCadence/speedCadenceScanState.ts","../src/sensors/speedCadence/speedCadenceSensor.ts","../src/sensors/speedCadence/speedCadenceScanner.ts","../src/sensors/speed/speedUtils.ts","../src/sensors/speed/speedSensorState.ts","../src/sensors/speed/speedScanState.ts","../src/sensors/speed/speedSensor.ts","../src/sensors/speed/speedScanner.ts","../src/sensors/cadence/cadenceUtils.ts","../src/sensors/cadence/cadenceSensorState.ts","../src/sensors/cadence/cadenceScanState.ts","../src/sensors/cadence/cadenceSensor.ts","../src/sensors/cadence/cadenceScanner.ts","../src/sensors/bicyclePower/bicyclePowerUtils.ts","../src/sensors/bicyclePower/bicyclePowerSensorState.ts","../src/sensors/bicyclePower/bicyclePowerScanState.ts","../src/sensors/bicyclePower/bicyclePowerSensor.ts","../src/sensors/bicyclePower/bicyclePowerScanner.ts","../src/sensors/fitnessEquipment/fitnessEquipmentUtils.ts","../src/sensors/fitnessEquipment/fitnessEquipmentSensorState.ts","../src/sensors/fitnessEquipment/fitnessEquipmentScanState.ts","../src/sensors/fitnessEquipment/fitnessEquipmentSensor.ts","../src/sensors/fitnessEquipment/fitnessEquipmentScanner.ts","../src/sensors/muscleOxygen/muscleOxygenUtils.ts","../src/sensors/muscleOxygen/muscleOxygenSensorState.ts","../src/sensors/muscleOxygen/muscleOxygenScanState.ts","../src/sensors/muscleOxygen/muscleOxygenSensor.ts","../src/sensors/muscleOxygen/muscleOxygenScanner.ts","../src/sensors/environment/environmentUtils.ts","../src/sensors/environment/environmentSensorState.ts","../src/sensors/environment/environmentScanState.ts","../src/sensors/environment/environmentSensor.ts","../src/sensors/environment/environmentScanner.ts"],"sourcesContent":["/**\r\n * A collection of constants used in the ANT+ protocol for wireless communication.\r\n * These constants define various message types, configuration parameters, events,\r\n * and capabilities used to control and manage channels, transmit data, and handle\r\n * protocol-specific operations.\r\n *\r\n * @class Constants\r\n * @see {@link https://www.thisisant.com/developer/resources/downloads#documents} for the ANT+ protocol documentation.\r\n */\r\nexport class Constants {\r\n    // Message Types\r\n    /**\r\n     * Represents a generic Radio Frequency (RF) message type used in the ANT+ protocol.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_RF: number = 0x01;\r\n\r\n    /**\r\n     * Represents a synchronization message used to align data transmission.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_TX_SYNC: number = 0xa4;\r\n\r\n    /**\r\n     * Default network number used by ANT+ devices.\r\n     * @type {number}\r\n     */\r\n    static readonly DEFAULT_NETWORK_NUMBER: number = 0x00;\r\n\r\n    // Configuration Messages\r\n    /**\r\n     * Unassigns a channel, making it available for reassignment or closing.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_UNASSIGN: number = 0x41;\r\n\r\n    /**\r\n     * Assigns a channel with a specific type and network number.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_ASSIGN: number = 0x42;\r\n\r\n    /**\r\n     * Sets the unique identifier for a channel.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_ID: number = 0x51;\r\n\r\n    /**\r\n     * Configures the message period for a channel, defining the frequency of data messages.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_PERIOD: number = 0x43;\r\n\r\n    /**\r\n     * Sets the timeout period for channel searching operations.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_SEARCH_TIMEOUT: number = 0x44;\r\n\r\n    /**\r\n     * Configures the frequency of the channel in the RF spectrum.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_FREQUENCY: number = 0x45;\r\n\r\n    /**\r\n     * Sets the transmission power level for a specific channel.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_TX_POWER: number = 0x60;\r\n\r\n    /**\r\n     * Sets the network key for secure communication between ANT+ devices.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_NETWORK_KEY: number = 0x46;\r\n\r\n    /**\r\n     * Defines the transmit power for the device.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_TX_POWER: number = 0x47;\r\n\r\n    /**\r\n     * Enables proximity search for devices within a specified range.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_PROXIMITY_SEARCH: number = 0x71;\r\n\r\n    /**\r\n     * Enables extended receive mode for handling additional data.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_ENABLE_RX_EXT: number = 0x66;\r\n\r\n    /**\r\n     * Configures the library settings for ANT+ communication.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_LIB_CONFIG: number = 0x6e;\r\n\r\n    /**\r\n     * Opens a channel for RX scan mode, allowing the device to search for broadcasts.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_OPEN_RX_SCAN: number = 0x5b;\r\n\r\n    // Notifications\r\n    /**\r\n     * Indicates a startup event, typically sent after a device reset or initialization.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_STARTUP: number = 0x6f;\r\n\r\n    // Control Messages\r\n    /**\r\n     * Resets the ANT+ device system.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_SYSTEM_RESET: number = 0x4a;\r\n\r\n    /**\r\n     * Opens a communication channel for data transmission.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_OPEN: number = 0x4b;\r\n\r\n    /**\r\n     * Closes a previously opened communication channel.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_CLOSE: number = 0x4c;\r\n\r\n    /**\r\n     * Requests a specific operation or status update for a channel.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_REQUEST: number = 0x4d;\r\n\r\n    // Data Messages\r\n    /**\r\n     * Transmits broadcast data over an open channel.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_BROADCAST_DATA: number = 0x4e;\r\n\r\n    /**\r\n     * Sends acknowledged data that requires a response confirmation.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_ACKNOWLEDGED_DATA: number = 0x4f;\r\n\r\n    /**\r\n     * Sends burst data packets over a channel, useful for high-throughput scenarios.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_BURST_DATA: number = 0x50;\r\n\r\n    // Channel Event Messages\r\n    /**\r\n     * Represents various events occurring on a channel, such as RX or TX completion.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_EVENT: number = 0x40;\r\n\r\n    // Requested Response Messages\r\n    /**\r\n     * Queries the status of a channel, returning details like state or assigned ID.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CHANNEL_STATUS: number = 0x52;\r\n\r\n    /**\r\n     * Retrieves the version of the ANT+ device software or protocol.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_VERSION: number = 0x3e;\r\n\r\n    /**\r\n     * Retrieves the capabilities of the ANT+ device, such as supported features.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_CAPABILITIES: number = 0x54;\r\n\r\n    /**\r\n     * Retrieves the unique serial number of the ANT+ device.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_SERIAL_NUMBER: number = 0x61;\r\n\r\n    // Message Parameters\r\n    /**\r\n     * Channel type for two-way data reception.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_TYPE_TWOWAY_RECEIVE: number = 0x00;\r\n\r\n    /**\r\n     * Channel type for two-way data transmission.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_TYPE_TWOWAY_TRANSMIT: number = 0x10;\r\n\r\n    /**\r\n     * Channel type for shared data reception.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_TYPE_SHARED_RECEIVE: number = 0x20;\r\n\r\n    /**\r\n     * Channel type for shared data transmission.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_TYPE_SHARED_TRANSMIT: number = 0x30;\r\n\r\n    /**\r\n     * Channel type for one-way data reception.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_TYPE_ONEWAY_RECEIVE: number = 0x40;\r\n\r\n    /**\r\n     * Channel type for one-way data transmission.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_TYPE_ONEWAY_TRANSMIT: number = 0x50;\r\n\r\n    /**\r\n     * Radio transmit power level: -20 dB.\r\n     * @type {number}\r\n     */\r\n    static readonly RADIO_TX_POWER_MINUS20DB: number = 0x00;\r\n\r\n    /**\r\n     * Radio transmit power level: -10 dB.\r\n     * @type {number}\r\n     */\r\n    static readonly RADIO_TX_POWER_MINUS10DB: number = 0x01;\r\n\r\n    /**\r\n     * Radio transmit power level: 0 dB.\r\n     * @type {number}\r\n     */\r\n    static readonly RADIO_TX_POWER_0DB: number = 0x02;\r\n\r\n    /**\r\n     * Radio transmit power level: +4 dB.\r\n     * @type {number}\r\n     */\r\n    static readonly RADIO_TX_POWER_PLUS4DB: number = 0x03;\r\n\r\n    // Event Codes\r\n    /**\r\n     * No error occurred in the response.\r\n     * @type {number}\r\n     */\r\n    static readonly RESPONSE_NO_ERROR: number = 0x00;\r\n\r\n    /**\r\n     * RX search timed out.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_RX_SEARCH_TIMEOUT: number = 0x01;\r\n\r\n    /**\r\n     * RX failed.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_RX_FAIL: number = 0x02;\r\n\r\n    /**\r\n     * TX completed successfully.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_TX: number = 0x03;\r\n\r\n    /**\r\n     * Transfer RX failed.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_TRANSFER_RX_FAILED: number = 0x04;\r\n\r\n    /**\r\n     * Transfer TX completed successfully.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_TRANSFER_TX_COMPLETED: number = 0x05;\r\n\r\n    /**\r\n     * Transfer TX failed.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_TRANSFER_TX_FAILED: number = 0x06;\r\n\r\n    /**\r\n     * Channel was closed.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_CHANNEL_CLOSED: number = 0x07;\r\n\r\n    /**\r\n     * RX failed; channel will go to search.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_RX_FAIL_GO_TO_SEARCH: number = 0x08;\r\n\r\n    /**\r\n     * Channel collision detected.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_CHANNEL_COLLISION: number = 0x09;\r\n\r\n    /**\r\n     * Transfer TX started.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_TRANSFER_TX_START: number = 0x0a;\r\n\r\n    // Error and State Codes\r\n    /**\r\n     * Channel is in the wrong state for the requested operation.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_IN_WRONG_STATE: number = 0x15;\r\n\r\n    /**\r\n     * Channel is not opened.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_NOT_OPENED: number = 0x16;\r\n\r\n    /**\r\n     * Channel ID is not set.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_ID_NOT_SET: number = 0x18;\r\n\r\n    /**\r\n     * Command to close all channels.\r\n     * @type {number}\r\n     */\r\n    static readonly CLOSE_ALL_CHANNELS: number = 0x19;\r\n\r\n    /**\r\n     * Transfer is currently in progress.\r\n     * @type {number}\r\n     */\r\n    static readonly TRANSFER_IN_PROGRESS: number = 0x1f;\r\n\r\n    /**\r\n     * Transfer sequence number error.\r\n     * @type {number}\r\n     */\r\n    static readonly TRANSFER_SEQUENCE_NUMBER_ERROR: number = 0x20;\r\n\r\n    /**\r\n     * Transfer is in an error state.\r\n     * @type {number}\r\n     */\r\n    static readonly TRANSFER_IN_ERROR: number = 0x21;\r\n\r\n    /**\r\n     * Message size exceeds allowed limit.\r\n     * @type {number}\r\n     */\r\n    static readonly MESSAGE_SIZE_EXCEEDS_LIMIT: number = 0x27;\r\n\r\n    /**\r\n     * Invalid message received.\r\n     * @type {number}\r\n     */\r\n    static readonly INVALID_MESSAGE: number = 0x28;\r\n\r\n    /**\r\n     * Invalid network number provided.\r\n     * @type {number}\r\n     */\r\n    static readonly INVALID_NETWORK_NUMBER: number = 0x29;\r\n\r\n    /**\r\n     * Invalid list ID provided.\r\n     * @type {number}\r\n     */\r\n    static readonly INVALID_LIST_ID: number = 0x30;\r\n\r\n    /**\r\n     * Invalid scan TX channel specified.\r\n     * @type {number}\r\n     */\r\n    static readonly INVALID_SCAN_TX_CHANNEL: number = 0x31;\r\n\r\n    /**\r\n     * Invalid parameter provided for a message or operation.\r\n     * @type {number}\r\n     */\r\n    static readonly INVALID_PARAMETER_PROVIDED: number = 0x33;\r\n\r\n    /**\r\n     * Event queue overflow occurred.\r\n     * @type {number}\r\n     */\r\n    static readonly EVENT_QUEUE_OVERFLOW: number = 0x35;\r\n\r\n    /**\r\n     * USB string write operation failed.\r\n     * @type {number}\r\n     */\r\n    static readonly USB_STRING_WRITE_FAIL: number = 0x70;\r\n\r\n    // Channel States\r\n    /**\r\n     * Channel is unassigned.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_STATE_UNASSIGNED: number = 0x00;\r\n\r\n    /**\r\n     * Channel is assigned.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_STATE_ASSIGNED: number = 0x01;\r\n\r\n    /**\r\n     * Channel is searching for another device.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_STATE_SEARCHING: number = 0x02;\r\n\r\n    /**\r\n     * Channel is tracking another device.\r\n     * @type {number}\r\n     */\r\n    static readonly CHANNEL_STATE_TRACKING: number = 0x03;\r\n\r\n    // Capability Flags\r\n    /**\r\n     * Device has no receive channels.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NO_RECEIVE_CHANNELS: number = 0x01;\r\n\r\n    /**\r\n     * Device has no transmit channels.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NO_TRANSMIT_CHANNELS: number = 0x02;\r\n\r\n    /**\r\n     * Device has no receive message capability.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NO_RECEIVE_MESSAGES: number = 0x04;\r\n\r\n    /**\r\n     * Device has no transmit message capability.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NO_TRANSMIT_MESSAGES: number = 0x08;\r\n\r\n    /**\r\n     * Device has no acknowledged message capability.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NO_ACKNOWLEDGED_MESSAGES: number = 0x10;\r\n\r\n    /**\r\n     * Device has no burst message capability.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NO_BURST_MESSAGES: number = 0x20;\r\n\r\n    /**\r\n     * Device supports network communication.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_NETWORK_ENABLED: number = 0x02;\r\n\r\n    /**\r\n     * Device serial number feature enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_SERIAL_NUMBER_ENABLED: number = 0x08;\r\n\r\n    /**\r\n     * Per-channel transmit power adjustment enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_PER_CHANNEL_TX_POWER_ENABLED: number = 0x10;\r\n\r\n    /**\r\n     * Low priority search capability enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_LOW_PRIORITY_SEARCH_ENABLED: number = 0x20;\r\n\r\n    /**\r\n     * Script feature enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_SCRIPT_ENABLED: number = 0x40;\r\n\r\n    /**\r\n     * Search list capability enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_SEARCH_LIST_ENABLED: number = 0x80;\r\n\r\n    /**\r\n     * LED feature enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_LED_ENABLED: number = 0x01;\r\n\r\n    /**\r\n     * Extended messaging enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_EXT_MESSAGE_ENABLED: number = 0x02;\r\n\r\n    /**\r\n     * Scan mode enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_SCAN_MODE_ENABLED: number = 0x04;\r\n\r\n    /**\r\n     * Proximity search capability enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_PROX_SEARCH_ENABLED: number = 0x10;\r\n\r\n    /**\r\n     * Extended channel assignment enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_EXT_ASSIGN_ENABLED: number = 0x20;\r\n\r\n    /**\r\n     * File share (ANT-FS) feature enabled.\r\n     * @type {number}\r\n     */\r\n    static readonly CAPABILITIES_FS_ANTFS_ENABLED: number = 0x40;\r\n\r\n    // Miscellaneous\r\n    /**\r\n     * Special value indicating that the timeout for an operation is set to never expire.\r\n     * @type {number}\r\n     */\r\n    static readonly TIMEOUT_NEVER: number = 0xff;\r\n}\r\n","import { Constants } from \"../types/constants.js\";\r\n\r\nexport class Messages {\r\n    static BUFFER_INDEX_MSG_LEN: number = 1;\r\n    static BUFFER_INDEX_MSG_TYPE: number = 2;\r\n    static BUFFER_INDEX_CHANNEL_NUM: number = 3;\r\n    static BUFFER_INDEX_MSG_DATA: number = 4;\r\n    static BUFFER_INDEX_EXT_MSG_BEGIN: number = 12;\r\n\r\n    static resetSystem(): Uint8Array {\r\n        const payload: number[] = [];\r\n        payload.push(0x00);\r\n        return this.buildMessage(payload, Constants.MESSAGE_SYSTEM_RESET);\r\n    }\r\n\r\n    static requestMessage(channel: number, messageId: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        payload.push(messageId);\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_REQUEST);\r\n    }\r\n\r\n    static setNetworkKey(): Uint8Array {\r\n        const payload: number[] = [];\r\n        payload.push(Constants.DEFAULT_NETWORK_NUMBER);\r\n        payload.push(0xb9);\r\n        payload.push(0xa5);\r\n        payload.push(0x21);\r\n        payload.push(0xfb);\r\n        payload.push(0xbd);\r\n        payload.push(0x72);\r\n        payload.push(0xc3);\r\n        payload.push(0x45);\r\n        return this.buildMessage(payload, Constants.MESSAGE_NETWORK_KEY);\r\n    }\r\n\r\n    static assignChannel(channel: number, type = \"receive\"): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        if (type === \"receive\") {\r\n            payload.push(Constants.CHANNEL_TYPE_TWOWAY_RECEIVE);\r\n        } else if (type === \"receive_only\") {\r\n            payload.push(Constants.CHANNEL_TYPE_ONEWAY_RECEIVE);\r\n        } else if (type === \"receive_shared\") {\r\n            payload.push(Constants.CHANNEL_TYPE_SHARED_RECEIVE);\r\n        } else if (type === \"transmit\") {\r\n            payload.push(Constants.CHANNEL_TYPE_TWOWAY_TRANSMIT);\r\n        } else if (type === \"transmit_only\") {\r\n            payload.push(Constants.CHANNEL_TYPE_ONEWAY_TRANSMIT);\r\n        } else if (type === \"transmit_shared\") {\r\n            payload.push(Constants.CHANNEL_TYPE_SHARED_TRANSMIT);\r\n        } else {\r\n            throw new Error(\"type not allowed\");\r\n        }\r\n        payload.push(Constants.DEFAULT_NETWORK_NUMBER);\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_ASSIGN);\r\n    }\r\n\r\n    static setDevice(channel: number, deviceId: number, deviceType: number, transmissionType: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        payload = payload.concat(this.intToLEHexArray(deviceId, 2));\r\n        payload = payload.concat(this.intToLEHexArray(deviceType));\r\n        payload = payload.concat(this.intToLEHexArray(transmissionType));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_ID);\r\n    }\r\n\r\n    static searchChannel(channel: number, timeout: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        payload = payload.concat(this.intToLEHexArray(timeout));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_SEARCH_TIMEOUT);\r\n    }\r\n\r\n    static setPeriod(channel: number, period: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        payload = payload.concat(this.intToLEHexArray(period));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_PERIOD);\r\n    }\r\n\r\n    static setFrequency(channel: number, frequency: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        payload = payload.concat(this.intToLEHexArray(frequency));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_FREQUENCY);\r\n    }\r\n\r\n    static setRxExt(): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(0));\r\n        payload = payload.concat(this.intToLEHexArray(1));\r\n        return this.buildMessage(payload, Constants.MESSAGE_ENABLE_RX_EXT);\r\n    }\r\n\r\n    static libConfig(channel: number, how: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        payload = payload.concat(this.intToLEHexArray(how));\r\n        return this.buildMessage(payload, Constants.MESSAGE_LIB_CONFIG);\r\n    }\r\n\r\n    static openRxScan(): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(0));\r\n        payload = payload.concat(this.intToLEHexArray(1));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_OPEN_RX_SCAN);\r\n    }\r\n\r\n    static openChannel(channel: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_OPEN);\r\n    }\r\n\r\n    static closeChannel(channel: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_CLOSE);\r\n    }\r\n\r\n    static unassignChannel(channel: number): Uint8Array {\r\n        let payload: number[] = [];\r\n        payload = payload.concat(this.intToLEHexArray(channel));\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_UNASSIGN);\r\n    }\r\n\r\n    static acknowledgedData(channel: number, payload: number[]): Uint8Array {\r\n        payload = this.intToLEHexArray(channel).concat(payload);\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_ACKNOWLEDGED_DATA);\r\n    }\r\n\r\n    static broadcastData(channel: number, payload: number[]): Uint8Array {\r\n        payload = this.intToLEHexArray(channel).concat(payload);\r\n        return this.buildMessage(payload, Constants.MESSAGE_CHANNEL_BROADCAST_DATA);\r\n    }\r\n\r\n    static buildMessage(payload: number[] = [], messageId = 0x00): Uint8Array {\r\n        const message: number[] = [];\r\n        message.push(Constants.MESSAGE_TX_SYNC);\r\n        message.push(payload.length);\r\n        message.push(messageId);\r\n        payload.forEach((byte) => {\r\n            message.push(byte);\r\n        });\r\n        message.push(this.getChecksum(message));\r\n\r\n        return new Uint8Array(message);\r\n    }\r\n\r\n    static intToLEHexArray(int: number, numBytes = 1): number[] {\r\n        numBytes = numBytes || 1;\r\n        const a: number[] = [];\r\n        const hexString = this.decimalToHex(int, numBytes * 2);\r\n        for (let i = hexString.length - 2; i >= 0; i -= 2) {\r\n            a.push(parseInt(hexString.substr(i, 2), 16));\r\n        }\r\n        return a;\r\n    }\r\n\r\n    static decimalToHex(d: number, numDigits: number): string {\r\n        let hex = Number(d).toString(16);\r\n        numDigits = numDigits || 2;\r\n        while (hex.length < numDigits) {\r\n            hex = \"0\" + hex;\r\n        }\r\n\r\n        return hex;\r\n    }\r\n\r\n    static getChecksum(message: number[]): number {\r\n        let checksum = 0;\r\n        message.forEach((byte) => {\r\n            checksum = (checksum ^ byte) % 0xff;\r\n        });\r\n\r\n        return checksum;\r\n    }\r\n}\r\n","import { BaseSensor } from \"../../sensors/baseSensor\";\r\nimport { Constants } from \"../../types/constants\";\r\nimport { DebugOptions } from \"../../types/debugOptions\";\r\nimport { USBDriverBase } from \"../../types/usbDriverBase\";\r\nimport { Messages } from \"../../utils/messages\";\r\nimport EventEmitter from \"events\";\r\nimport usb, { LibUSBException } from \"usb\";\r\n\r\n/**\r\n * NodeUSBDriver class handles the connection and communication with USB devices using the node-usb library.\r\n * It manages device setup, communication, sensor attachment, and data processing.\r\n *\r\n * This class extends EventEmitter to handle events and implements the USBDriverBase interface.\r\n *\r\n * @extends EventEmitter\r\n * @implements USBDriverBase\r\n */\r\nexport class NodeUSBDriver extends EventEmitter implements USBDriverBase {\r\n    /**\r\n     * List of USB devices currently in use.\r\n     * Tracks all connected devices used by this driver.\r\n     *\r\n     * @type {usb.Device[]}\r\n     * @private\r\n     */\r\n    private static deviceInUse: usb.Device[] = [];\r\n\r\n    /**\r\n     * The USB device instance.\r\n     * Holds a reference to the connected USB device, if any.\r\n     *\r\n     * @type {usb.Device|undefined}\r\n     * @private\r\n     */\r\n    private device: usb.Device | undefined;\r\n\r\n    /**\r\n     * The USB interface of the device.\r\n     * Used to interact with the endpoints of the connected USB device.\r\n     *\r\n     * @type {usb.Interface|undefined}\r\n     * @private\r\n     */\r\n    private iface: usb.Interface | undefined;\r\n\r\n    /**\r\n     * Indicates if the kernel driver was detached.\r\n     * Marks whether the kernel driver was detached during setup for re-attachment upon disconnection.\r\n     *\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    private detachedKernelDriver = false;\r\n\r\n    /**\r\n     * The input endpoint for reading data.\r\n     * Used for receiving data from the USB device.\r\n     *\r\n     * @type {(usb.InEndpoint & EventEmitter)|undefined}\r\n     * @private\r\n     */\r\n    private inEndpoint: (usb.InEndpoint & EventEmitter) | undefined;\r\n\r\n    /**\r\n     * The output endpoint for sending data.\r\n     * Used for sending data to the USB device.\r\n     *\r\n     * @type {(usb.OutEndpoint & EventEmitter)|undefined}\r\n     * @private\r\n     */\r\n    private outEndpoint: (usb.OutEndpoint & EventEmitter) | undefined;\r\n\r\n    /**\r\n     * Stores leftover data from previous reads.\r\n     * Used to buffer partial data when reading from the USB device.\r\n     *\r\n     * @type {Uint8Array|undefined}\r\n     * @private\r\n     */\r\n    private leftover: Uint8Array | undefined;\r\n\r\n    /**\r\n     * The number of channels currently used.\r\n     * Tracks how many channels are actively being used.\r\n     *\r\n     * @type {number}\r\n     */\r\n    usedChannels: number = 0;\r\n\r\n    /**\r\n     * List of attached sensors.\r\n     * Holds the list of sensors currently connected to the USB driver.\r\n     *\r\n     * @type {BaseSensor[]}\r\n     * @private\r\n     */\r\n    private attachedSensors: BaseSensor[] = [];\r\n\r\n    /**\r\n     * The maximum number of channels available for communication.\r\n     * Defines the total number of channels the device can handle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    maxChannels: number = 0;\r\n\r\n    /**\r\n     * Indicates if the device can scan for channels.\r\n     * Represents whether the USB device has scanning capabilities.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    _canScan: boolean = false;\r\n\r\n    /**\r\n     * Defines whether to throw LibUSB exceptions when errors occur during USB communication.\r\n     * Default value is set to `false`.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    throwLibUSBException: boolean = false;\r\n\r\n    /**\r\n     * Creates an instance of NodeUSBDriver.\r\n     * Initializes the driver with vendor ID, product ID, and optional debug options.\r\n     *\r\n     * @param {number} idVendor - The vendor ID of the USB device.\r\n     * @param {number} idProduct - The product ID of the USB device.\r\n     * @param {DebugOptions} [debugOptions={}] - Optional debug options for USB operations.\r\n     *                                          Includes usbDebugLevel and throwLibUSBException.\r\n     *\r\n     * @example\r\n     * const driver = new NodeUSBDriver(0x1234, 0x5678, { usbDebugLevel: 2, throwLibUSBException: true });\r\n     */\r\n    constructor(\r\n        private idVendor: number,\r\n        private idProduct: number,\r\n        debugOptions: DebugOptions = {}\r\n    ) {\r\n        super();\r\n        this.setMaxListeners(50); // Set maximum number of listeners to 50\r\n        usb.usb.setDebugLevel(debugOptions.usbDebugLevel || 0); // Set USB debug level\r\n        this.throwLibUSBException = debugOptions.throwLibUSBException || false; // Set exception throwing option\r\n    }\r\n\r\n    /**\r\n     * Checks if a new sensor can be attached to the driver.\r\n     * It verifies whether the current number of used channels is less than the maximum available channels.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if a new sensor can be attached, otherwise false.\r\n     *\r\n     * @example\r\n     * const canAttach = await this.stick.canAttach();\r\n     * if (canAttach) {\r\n     *   console.log(\"A new sensor can be attached.\");\r\n     * } else {\r\n     *   console.log(\"Cannot attach sensor: Maximum number of channels reached.\");\r\n     * }\r\n     */\r\n    async canAttach(): Promise<boolean> {\r\n        return Promise.resolve(this.usedChannels < this.maxChannels);\r\n    }\r\n\r\n    /**\r\n     * Checks if the device can scan for channels.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if the device can scan, otherwise false.\r\n     */\r\n    async canScan(): Promise<boolean> {\r\n        return Promise.resolve(this._canScan);\r\n    }\r\n\r\n    /**\r\n     * Opens a connection to the USB device and sets up endpoints for communication.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if the device is successfully opened, otherwise false.\r\n     * @example\r\n     * const driver = new NodeUSBDriver(1234, 5678);\r\n     * driver.open().then((result) => {\r\n     *   if (result) {\r\n     *     console.log(\"Device successfully opened\");\r\n     *   } else {\r\n     *     console.error(\"Failed to open device\");\r\n     *   }\r\n     * });\r\n     */\r\n    async open(): Promise<boolean> {\r\n        const devices = this.getDevices();\r\n\r\n        while (devices.length) {\r\n            try {\r\n                const device = devices.shift();\r\n                if (!device) {\r\n                    continue;\r\n                }\r\n\r\n                this.device = device;\r\n                this.device.open();\r\n                this.iface = this.device.interfaces![0];\r\n\r\n                try {\r\n                    if (this.iface && this.iface.isKernelDriverActive()) {\r\n                        this.detachedKernelDriver = true;\r\n                        this.iface.detachKernelDriver();\r\n                    }\r\n                } catch {\r\n                    // Ignore kernel driver errors\r\n                }\r\n\r\n                this.iface.claim();\r\n                break;\r\n            } catch (error) {\r\n                if (error && this.throwLibUSBException) {\r\n                    const errno = (error as LibUSBException).errno;\r\n                    switch (errno) {\r\n                        case usb.usb.LIBUSB_ERROR_ACCESS:\r\n                            throw new Error(\"LIBUSB_ERROR_ACCESS: Access denied (insufficient permissions)\");\r\n                        case usb.usb.LIBUSB_ERROR_NO_DEVICE:\r\n                            throw new Error(\"LIBUSB_ERROR_NO_DEVICE: Device has been disconnected\");\r\n                        case usb.usb.LIBUSB_ERROR_BUSY:\r\n                            throw new Error(\"LIBUSB_ERROR_BUSY: Resource busy\");\r\n                        default:\r\n                            console.error(\"Unknown LIBUSB error:\", error);\r\n                            break;\r\n                    }\r\n                } else {\r\n                    // Ignore errors and try with the next device\r\n                }\r\n\r\n                if (this.device) {\r\n                    this.device.close();\r\n                }\r\n                this.device = undefined;\r\n                this.iface = undefined;\r\n            }\r\n        }\r\n\r\n        if (!this.device) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        NodeUSBDriver.deviceInUse.push(this.device);\r\n\r\n        if (!this.iface) {\r\n            throw new Error(\"Interface not initialized.\");\r\n        }\r\n\r\n        this.inEndpoint = this.iface.endpoints[0] as usb.InEndpoint;\r\n        this.inEndpoint.on(\"data\", (data: Uint8Array) => {\r\n            this.onData(data).catch((error) => {\r\n                console.error(error);\r\n            });\r\n        });\r\n\r\n        this.inEndpoint.on(\"error\", (err: Error) => {\r\n            console.error(\"ERROR RECV: \", err);\r\n        });\r\n\r\n        this.inEndpoint.on(\"end\", () => {\r\n            //console.info(\"STOP RECV\");\r\n        });\r\n\r\n        this.inEndpoint.startPoll();\r\n\r\n        this.outEndpoint = this.iface.endpoints[1] as usb.OutEndpoint;\r\n\r\n        await this.reset();\r\n\r\n        return Promise.resolve(true);\r\n    }\r\n\r\n    /**\r\n     * Closes the connection to the USB device and releases the interface.\r\n     *\r\n     * @returns {Promise<void>} Resolves when the device is closed.\r\n     * @example\r\n     * const driver = new NodeUSBDriver(1234, 5678);\r\n     * driver.open().then(() => {\r\n     *   driver.close().then(() => console.log(\"Device closed\"));\r\n     * });\r\n     */\r\n    async close(): Promise<void> {\r\n        await this.detachAll();\r\n\r\n        if (this.inEndpoint) {\r\n            this.inEndpoint.stopPoll(() => {\r\n                if (this.iface) {\r\n                    this.iface.release(true, () => {\r\n                        if (this.detachedKernelDriver) {\r\n                            this.detachedKernelDriver = false;\r\n                            try {\r\n                                this.iface?.attachKernelDriver();\r\n                            } catch {\r\n                                // Ignore kernel driver errors\r\n                            }\r\n                        }\r\n                        this.iface = undefined;\r\n                        if (this.device) {\r\n                            this.device.reset(() => {\r\n                                this.device?.close();\r\n                                this.emit(\"shutdown\");\r\n                                const devIdx = NodeUSBDriver.deviceInUse.indexOf(this.device!);\r\n                                if (devIdx >= 0) {\r\n                                    NodeUSBDriver.deviceInUse.splice(devIdx, 1);\r\n                                }\r\n                                if (usb.usb.listenerCount(\"attach\")) {\r\n                                    usb.usb.emit(\"attach\", this.device!);\r\n                                }\r\n                                this.device = undefined;\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads data from the USB device and processes it.\r\n     *\r\n     * @param {Uint8Array} data - The data received from the USB device.\r\n     * @returns {Promise<void>} Resolves when the data has been processed.\r\n     * @example\r\n     * const data = new Uint8Array([0x01, 0x02, 0x03]);\r\n     * driver.read(data).then(() => console.log(\"Data processed\"));\r\n     */\r\n    async read(data: Uint8Array): Promise<void> {\r\n        const dataView = new DataView(data.buffer);\r\n        const messageId = dataView.getUint8(2);\r\n\r\n        if (messageId === Constants.MESSAGE_STARTUP) {\r\n            await this.write(Messages.requestMessage(0, Constants.MESSAGE_CAPABILITIES));\r\n        } else if (messageId === Constants.MESSAGE_CAPABILITIES) {\r\n            this.maxChannels = dataView.getUint8(3);\r\n            this._canScan = (dataView.getUint8(7) & 0x06) === 0x06;\r\n            await this.write(Messages.setNetworkKey());\r\n        } else if (messageId === Constants.MESSAGE_CHANNEL_EVENT && dataView.getUint8(4) === Constants.MESSAGE_NETWORK_KEY) {\r\n            this.emit(\"startup\", data);\r\n        } else {\r\n            this.emit(\"read\", data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes data to the USB device.\r\n     *\r\n     * @param {Uint8Array} data - The data to be sent to the USB device.\r\n     * @returns {Promise<void>} Resolves when the data has been written.\r\n     * @example\r\n     * const data = new Uint8Array([0x01, 0x02, 0x03]);\r\n     * driver.write(data).then(() => console.log(\"Data sent\"));\r\n     */\r\n    async write(data: Uint8Array): Promise<void> {\r\n        await new Promise<void>((resolve, reject) => {\r\n            if (this.outEndpoint) {\r\n                this.outEndpoint.transfer(Buffer.from(data), (error) => {\r\n                    if (error) {\r\n                        console.error(\"ERROR SEND: \", error);\r\n                        reject(error);\r\n                    } else {\r\n                        resolve();\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resets the device and its channels, and sends a reset message to the system.\r\n     *\r\n     * @returns {Promise<void>} Resolves when the reset is completed.\r\n     * @example\r\n     * driver.reset().then(() => console.log(\"Device reset\"));\r\n     */\r\n    async reset(): Promise<void> {\r\n        await this.detachAll();\r\n        this.maxChannels = 0;\r\n        this.usedChannels = 0;\r\n        await this.write(Messages.resetSystem());\r\n    }\r\n\r\n    /**\r\n     * Attaches a sensor to the driver and assigns it a channel.\r\n     *\r\n     * @param {BaseSensor} sensor - The sensor to attach.\r\n     * @param {boolean} forScan - Whether the sensor is being attached for scanning.\r\n     * @returns {Promise<boolean>} Resolves with true if the sensor was successfully attached, otherwise false.\r\n     * @example\r\n     * const sensor = new BaseSensor();\r\n     * driver.attach(sensor, true).then((attached) => {\r\n     *   if (attached) console.log(\"Sensor attached\");\r\n     * });\r\n     */\r\n    async attach(sensor: BaseSensor, forScan: boolean): Promise<boolean> {\r\n        if (this.usedChannels < 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        if (forScan && this.usedChannels !== 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        if (!forScan && this.maxChannels <= this.usedChannels) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        this.usedChannels = forScan ? -1 : this.usedChannels + 1;\r\n        this.attachedSensors.push(sensor);\r\n\r\n        return Promise.resolve(true);\r\n    }\r\n\r\n    /**\r\n     * Detaches a sensor from the driver.\r\n     *\r\n     * @param {BaseSensor} sensor - The sensor to detach.\r\n     * @returns {Promise<boolean>} Resolves with true if the sensor was successfully detached, otherwise false.\r\n     * @example\r\n     * const sensor = new BaseSensor();\r\n     * driver.detach(sensor).then((detached) => {\r\n     *   if (detached) console.log(\"Sensor detached\");\r\n     * });\r\n     */\r\n    async detach(sensor: BaseSensor): Promise<boolean> {\r\n        const idx = this.attachedSensors.indexOf(sensor);\r\n        if (idx < 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        this.usedChannels = this.usedChannels < 0 ? 0 : this.usedChannels - 1;\r\n        this.attachedSensors.splice(idx, 1);\r\n\r\n        return Promise.resolve(true);\r\n    }\r\n\r\n    /**\r\n     * Checks if a USB device is present.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if a device is present, otherwise false.\r\n     */\r\n    async isPresent(): Promise<boolean> {\r\n        return Promise.resolve(this.getDevices().length > 0);\r\n    }\r\n\r\n    /**\r\n     * Checks if the driver is currently scanning.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if the driver is scanning, otherwise false.\r\n     */\r\n    async isScanning(): Promise<boolean> {\r\n        return Promise.resolve(this.usedChannels === -1);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a list of USB devices matching the specified vendor and product IDs.\r\n     *\r\n     * @private\r\n     * @returns {usb.usb.Device[]} An array of USB devices that match the specified criteria.\r\n     */\r\n    private getDevices(): usb.usb.Device[] {\r\n        const allDevices = usb.getDeviceList();\r\n        return allDevices.filter((d) => d.deviceDescriptor.idVendor === this.idVendor && d.deviceDescriptor.idProduct === this.idProduct).filter((d) => NodeUSBDriver.deviceInUse.indexOf(d) === -1);\r\n    }\r\n\r\n    /**\r\n     * Detaches all sensors from the USB driver.\r\n     *\r\n     * @private\r\n     * @returns {Promise<void>} Resolves when all sensors are detached.\r\n     */\r\n    private async detachAll(): Promise<void> {\r\n        const copy = this.attachedSensors;\r\n        for (const sensor of copy) {\r\n            await sensor.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles data received from the USB device and processes the messages.\r\n     *\r\n     * @private\r\n     * @param {Uint8Array} data - The data received from the USB device.\r\n     * @returns {Promise<void>} Resolves when the data has been processed.\r\n     */\r\n    private async onData(data: Uint8Array) {\r\n        if (!data.length) {\r\n            return;\r\n        }\r\n\r\n        if (this.leftover) {\r\n            data = this.concatUint8Arrays(this.leftover, data);\r\n            this.leftover = undefined;\r\n        }\r\n\r\n        const dataView = new DataView(data.buffer);\r\n\r\n        if (dataView.getUint8(0) !== 0xa4) {\r\n            throw new Error(\"SYNC missing\");\r\n        }\r\n\r\n        const len = data.length;\r\n        let beginBlock = 0;\r\n        while (beginBlock < len) {\r\n            if (beginBlock + 1 === len) {\r\n                this.leftover = data.slice(beginBlock);\r\n                break;\r\n            }\r\n            const blockLen = dataView.getUint8(beginBlock + 1);\r\n            const endBlock = beginBlock + blockLen + 4;\r\n            if (endBlock > len) {\r\n                this.leftover = data.slice(beginBlock);\r\n                break;\r\n            }\r\n            const readData = data.slice(beginBlock, endBlock);\r\n            await this.read(readData);\r\n            beginBlock = endBlock;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Concatenates two Uint8Array objects into one.\r\n     *\r\n     * @private\r\n     * @param {Uint8Array} arr1 - The first array.\r\n     * @param {Uint8Array} arr2 - The second array.\r\n     * @returns {Uint8Array} The concatenated result.\r\n     */\r\n    private concatUint8Arrays(arr1: Uint8Array, arr2: Uint8Array): Uint8Array {\r\n        const result = new Uint8Array(arr1.length + arr2.length);\r\n        result.set(arr1, 0);\r\n        result.set(arr2, arr1.length);\r\n        return result;\r\n    }\r\n}\r\n","import { DebugOptions } from \"../types/debugOptions.js\";\r\nimport { NodeUSBDriver } from \"./driver/nodeUSBDriver.js\";\r\n\r\n/**\r\n * Class representing a Garmin Stick 2 USB driver, which extends the base USBDriver class.\r\n *\r\n * @category Drivers\r\n * @extends NodeUSBDriver\r\n */\r\nexport class GarminStick2 extends NodeUSBDriver {\r\n    /**\r\n     * Creates an instance of GarminStick2.\r\n     *\r\n     * @param {DebugOptions} [debugOptions={}] - Optional debug options for USB operations.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const garminStick = new GarminStick2();\r\n     * garminStick.open(); // Opens the connection to the Garmin Stick 2 device.\r\n     * ```\r\n     */\r\n    constructor(debugOptions: DebugOptions = {}) {\r\n        super(0x0fcf, 0x1008, debugOptions);\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a Garmin Stick 3 USB driver, which extends the base USBDriver class.\r\n *\r\n * @category Drivers\r\n * @extends NodeUSBDriver\r\n */\r\nexport class GarminStick3 extends NodeUSBDriver {\r\n    /**\r\n     * Creates an instance of GarminStick3.\r\n     *\r\n     * @param {DebugOptions} [debugOptions={}] - Optional debug options for USB operations.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const garminStick = new GarminStick3({ usbDebugLevel: 1 });\r\n     * garminStick.open(); // Opens the connection to the Garmin Stick 3 device.\r\n     * ```\r\n     */\r\n    constructor(debugOptions: DebugOptions = {}) {\r\n        super(0x0fcf, 0x1009, debugOptions);\r\n    }\r\n}\r\n","/**\r\n * An array of objects representing supported hardware devices, each identified by a vendor ID and product ID.\r\n * This array is used to filter and identify specific USB devices that are supported by the system.\r\n *\r\n * @type {Array<{ vendorId: number, productId: number }>}\r\n *\r\n * @example\r\n * // Example of accessing the supported hardware list\r\n * console.log(supportHardware);\r\n * // Output: [{ vendorId: 0x0fcf, productId: 0x1008 }, { vendorId: 0x0fcf, productId: 0x1009 }]\r\n */\r\nexport const supportHardware: Array<{ vendorId: number; productId: number }> = [\r\n    { vendorId: 0x0fcf, productId: 0x1008 }, // Device GarminStick2\r\n    { vendorId: 0x0fcf, productId: 0x1009 }, // Device GarminStick3\r\n];\r\n","import { BaseSensor } from \"../../sensors/baseSensor\";\r\nimport { USBDriverBase } from \"../../types/usbDriverBase\";\r\nimport EventEmitter from \"events\";\r\nimport { supportHardware } from \"./usbDriverUtils\";\r\nimport { Messages } from \"../../utils/messages\";\r\nimport { Constants } from \"../../types/constants\";\r\n\r\n/**\r\n * WebUSBDriver is a class that manages the connection and communication with USB devices using the WebUSB API.\r\n * It handles device setup, communication, and sensor attachment.\r\n *\r\n * @extends EventEmitter\r\n * @implements USBDriverBase\r\n */\r\nexport class WebUSBDriver extends EventEmitter implements USBDriverBase {\r\n    /**\r\n     * Stores the USB devices currently in use.\r\n     * @type {USBDevice[]}\r\n     * @private\r\n     */\r\n    private static deviceInUse: USBDevice[] = [];\r\n\r\n    /**\r\n     * The current USB device.\r\n     * @type {USBDevice|undefined}\r\n     * @private\r\n     */\r\n    private device: USBDevice | undefined;\r\n\r\n    /**\r\n     * The USB interface of the connected device.\r\n     * @type {USBInterface|undefined}\r\n     * @private\r\n     */\r\n    private iface: USBInterface | undefined;\r\n\r\n    /**\r\n     * The input endpoint for communication.\r\n     * @type {USBEndpoint|undefined}\r\n     * @private\r\n     */\r\n    private inEndpoint: USBEndpoint | undefined;\r\n\r\n    /**\r\n     * The output endpoint for communication.\r\n     * @type {USBEndpoint|undefined}\r\n     * @private\r\n     */\r\n    private outEndpoint: USBEndpoint | undefined;\r\n\r\n    /**\r\n     * Stores any leftover data from previous USB reads.\r\n     * @type {Uint8Array|undefined}\r\n     * @private\r\n     */\r\n    private leftover: Uint8Array | undefined;\r\n\r\n    /**\r\n     * The number of channels currently used.\r\n     * @type {number}\r\n     */\r\n    usedChannels: number = 0;\r\n\r\n    /**\r\n     * The sensors attached to the driver.\r\n     * @type {BaseSensor[]}\r\n     * @private\r\n     */\r\n    private attachedSensors: BaseSensor[] = [];\r\n\r\n    /**\r\n     * Controller for aborting asynchronous operations.\r\n     * @type {AbortController}\r\n     * @private\r\n     */\r\n    private abortController: AbortController;\r\n\r\n    /**\r\n     * Signal for aborting asynchronous operations.\r\n     * @type {AbortSignal}\r\n     * @private\r\n     */\r\n    private signal: AbortSignal;\r\n\r\n    /**\r\n     * The maximum number of channels available for communication.\r\n     * @type {number}\r\n     */\r\n    maxChannels: number = 0;\r\n\r\n    /**\r\n     * Indicates whether the device can scan.\r\n     * @type {boolean}\r\n     */\r\n    _canScan: boolean = false;\r\n\r\n    /**\r\n     * Initializes the WebUSBDriver instance, setting up the abort controller and signal.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.setMaxListeners(50);\r\n        this.abortController = new AbortController();\r\n        this.signal = this.abortController.signal;\r\n    }\r\n\r\n    /**\r\n     * Checks if a new sensor can be attached to the driver.\r\n     * It verifies whether the current number of used channels is less than the maximum available channels.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if a new sensor can be attached, otherwise false.\r\n     *\r\n     * @example\r\n     * const canAttach = await this.stick.canAttach();\r\n     * if (canAttach) {\r\n     *   console.log(\"A new sensor can be attached.\");\r\n     * } else {\r\n     *   console.log(\"Cannot attach sensor: Maximum number of channels reached.\");\r\n     * }\r\n     */\r\n    async canAttach(): Promise<boolean> {\r\n        return Promise.resolve(this.usedChannels < this.maxChannels);\r\n    }\r\n\r\n    /**\r\n     * Checks if the device can scan for channels.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if the device can scan, otherwise false.\r\n     */\r\n    async canScan(): Promise<boolean> {\r\n        return Promise.resolve(this._canScan);\r\n    }\r\n\r\n    /**\r\n     * Opens a connection to the USB device and initializes the endpoints.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if the device was successfully opened, otherwise false.\r\n     */\r\n    public async open(): Promise<boolean> {\r\n        try {\r\n            if (!this.device) {\r\n                this.device = await navigator.usb.requestDevice({ filters: supportHardware });\r\n            }\r\n\r\n            await this.device.open();\r\n            this.iface = this.device.configuration?.interfaces[0];\r\n\r\n            if (!this.iface) {\r\n                throw new Error(\"No interface configuration found.\");\r\n            }\r\n\r\n            await this.device.claimInterface(this.iface.interfaceNumber);\r\n\r\n            WebUSBDriver.deviceInUse.push(this.device);\r\n\r\n            this.inEndpoint = this.iface.alternate.endpoints.find((e) => e.direction === \"in\");\r\n            this.outEndpoint = this.iface.alternate.endpoints.find((e) => e.direction === \"out\");\r\n\r\n            if (!this.inEndpoint || !this.outEndpoint) {\r\n                throw new Error(\"In or Out endpoint not found.\");\r\n            }\r\n\r\n            await this.reset();\r\n            await this.readLoop();\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.log(error);\r\n            await this.close();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Continuously reads data from the USB device.\r\n     * Recursively calls itself after each read until aborted.\r\n     *\r\n     * @private\r\n     * @returns {Promise<void>} Resolves when the read loop is completed or aborted.\r\n     */\r\n    private async readLoop(): Promise<void> {\r\n        if (this.signal.aborted || !this.inEndpoint) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const result = await this.device?.transferIn(this.inEndpoint.endpointNumber, this.inEndpoint.packetSize);\r\n            if (!result || !result.data) {\r\n                return this.readLoop();\r\n            }\r\n\r\n            let buffer = new Uint8Array(result.data.buffer);\r\n\r\n            if (this.leftover) {\r\n                buffer = this.concatUint8Arrays(this.leftover, buffer);\r\n                this.leftover = undefined;\r\n            }\r\n\r\n            const dataView = new DataView(buffer.buffer);\r\n\r\n            if (dataView.getUint8(0) !== 0xa4) {\r\n                console.error(\"SYNC missing\");\r\n                return this.readLoop();\r\n            }\r\n\r\n            let beginBlock = 0;\r\n            const len = buffer.length;\r\n\r\n            while (beginBlock < len) {\r\n                if (beginBlock + 1 === len) {\r\n                    this.leftover = buffer.slice(beginBlock);\r\n                    break;\r\n                }\r\n\r\n                const blockLen = dataView.getUint8(beginBlock + 1);\r\n                const endBlock = beginBlock + blockLen + 4;\r\n\r\n                if (endBlock > len) {\r\n                    this.leftover = buffer.slice(beginBlock);\r\n                    break;\r\n                }\r\n\r\n                const readData = buffer.slice(beginBlock, endBlock);\r\n                await this.read(readData);\r\n                beginBlock = endBlock;\r\n            }\r\n        } catch (error) {\r\n            if (!this.signal.aborted) {\r\n                throw error;\r\n            }\r\n        }\r\n\r\n        return this.readLoop();\r\n    }\r\n\r\n    /**\r\n     * Closes the connection to the USB device and cleans up.\r\n     *\r\n     * @returns {Promise<void>} Resolves when the device is closed.\r\n     */\r\n    public async close(): Promise<void> {\r\n        this.cancelReadLoop();\r\n        await this.detachAll();\r\n\r\n        if (this.device) {\r\n            try {\r\n                await this.device.close();\r\n            } catch (error) {\r\n                console.error(\"Error closing device:\", error);\r\n            }\r\n\r\n            const devIdx = WebUSBDriver.deviceInUse.indexOf(this.device);\r\n            if (devIdx >= 0) {\r\n                WebUSBDriver.deviceInUse.splice(devIdx, 1);\r\n            }\r\n\r\n            this.emit(\"shutdown\");\r\n            this.device = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancels the current read loop by aborting the signal.\r\n     */\r\n    public cancelReadLoop() {\r\n        if (!this.signal.aborted) {\r\n            this.abortController.abort();\r\n            console.log(\"Read loop abort requested.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes the data received from the USB device.\r\n     *\r\n     * @param {Uint8Array} data The data received from the USB device.\r\n     * @returns {Promise<void>} Resolves when the data has been processed.\r\n     */\r\n    public async read(data: Uint8Array): Promise<void> {\r\n        const dataView = new DataView(data.buffer);\r\n        const messageId = dataView.getUint8(2);\r\n\r\n        if (messageId === Constants.MESSAGE_STARTUP) {\r\n            await this.write(Messages.requestMessage(0, Constants.MESSAGE_CAPABILITIES));\r\n        } else if (messageId === Constants.MESSAGE_CAPABILITIES) {\r\n            this.maxChannels = dataView.getUint8(3);\r\n            this._canScan = (dataView.getUint8(7) & 0x06) === 0x06;\r\n            await this.write(Messages.setNetworkKey());\r\n        } else if (messageId === Constants.MESSAGE_CHANNEL_EVENT && dataView.getUint8(4) === Constants.MESSAGE_NETWORK_KEY) {\r\n            this.emit(\"startup\", data);\r\n        } else {\r\n            this.emit(\"read\", data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes data to the USB device.\r\n     *\r\n     * @param {Uint8Array} data The data to be sent to the USB device.\r\n     * @returns {Promise<void>} Resolves when the data has been written.\r\n     */\r\n    public async write(data: Uint8Array): Promise<void> {\r\n        if (this.device && this.outEndpoint) {\r\n            await this.device.transferOut(this.outEndpoint.endpointNumber, data as Uint8Array<ArrayBuffer>);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the device and channels, and sends a reset message to the system.\r\n     *\r\n     * @returns {Promise<void>} Resolves when the reset is completed.\r\n     */\r\n    public async reset(): Promise<void> {\r\n        await this.detachAll();\r\n        this.maxChannels = 0;\r\n        this.usedChannels = 0;\r\n        await this.write(Messages.resetSystem());\r\n    }\r\n\r\n    /**\r\n     * Attaches a sensor to the driver and assigns it a channel.\r\n     *\r\n     * @param {BaseSensor} sensor The sensor to attach.\r\n     * @param {boolean} forScan Whether the sensor is being attached for scanning.\r\n     * @returns {Promise<boolean>} Resolves with true if the sensor was successfully attached, otherwise false.\r\n     */\r\n    public async attach(sensor: BaseSensor, forScan: boolean): Promise<boolean> {\r\n        if (this.usedChannels < 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        if (forScan && this.usedChannels !== 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n        if (!forScan && this.maxChannels <= this.usedChannels) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        this.usedChannels = forScan ? -1 : this.usedChannels + 1;\r\n        this.attachedSensors.push(sensor);\r\n\r\n        return Promise.resolve(true);\r\n    }\r\n\r\n    /**\r\n     * Detaches a sensor from the driver.\r\n     *\r\n     * @param {BaseSensor} sensor The sensor to detach.\r\n     * @returns {Promise<boolean>} Resolves with true if the sensor was successfully detached, otherwise false.\r\n     */\r\n    public async detach(sensor: BaseSensor): Promise<boolean> {\r\n        const idx = this.attachedSensors.indexOf(sensor);\r\n        if (idx < 0) {\r\n            return Promise.resolve(false);\r\n        }\r\n\r\n        this.usedChannels = this.usedChannels < 0 ? 0 : this.usedChannels - 1;\r\n        this.attachedSensors.splice(idx, 1);\r\n\r\n        return Promise.resolve(true);\r\n    }\r\n\r\n    /**\r\n     * Checks if a device is currently connected.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if a device is present, otherwise false.\r\n     */\r\n    public async isPresent(): Promise<boolean> {\r\n        return Promise.resolve(!!this.device);\r\n    }\r\n\r\n    /**\r\n     * Checks if the device is currently scanning.\r\n     *\r\n     * @returns {Promise<boolean>} Resolves with true if the device is scanning, otherwise false.\r\n     */\r\n    public async isScanning(): Promise<boolean> {\r\n        return Promise.resolve(this.usedChannels === -1);\r\n    }\r\n\r\n    /**\r\n     * Detaches all sensors from the driver.\r\n     *\r\n     * @private\r\n     * @returns {Promise<void>} Resolves when all sensors have been detached.\r\n     */\r\n    private async detachAll(): Promise<void> {\r\n        for (const sensor of this.attachedSensors.slice()) {\r\n            await sensor.detach();\r\n        }\r\n\r\n        this.attachedSensors = [];\r\n    }\r\n\r\n    /**\r\n     * Concatenates two Uint8Array objects into one.\r\n     *\r\n     * @private\r\n     * @param {Uint8Array} arr1 The first array.\r\n     * @param {Uint8Array} arr2 The second array.\r\n     * @returns {Uint8Array} The concatenated result.\r\n     */\r\n    private concatUint8Arrays(arr1: Uint8Array, arr2: Uint8Array): Uint8Array {\r\n        const result = new Uint8Array(arr1.length + arr2.length);\r\n        result.set(arr1, 0);\r\n        result.set(arr2, arr1.length);\r\n        return result;\r\n    }\r\n}\r\n","import { WebUSBDriver } from \"./driver/webUSBDriver.js\";\r\n\r\n/**\r\n * WebUsbStick class extends the WebUSBDriver to represent a specific USB stick that uses the WebUSB API.\r\n * It checks for WebUSB API availability in the environment before initializing.\r\n *\r\n * @category Drivers\r\n * @extends WebUSBDriver\r\n */\r\nexport class WebUsbStick extends WebUSBDriver {\r\n    /**\r\n     * Creates an instance of WebUsbStick.\r\n     * Throws an error if the WebUSB API is not available in the current environment (e.g., unsupported browsers).\r\n     *\r\n     * @throws {Error} If the WebUSB API is not available in the environment.\r\n     *\r\n     * @example\r\n     * try {\r\n     *   const usbStick = new WebUsbStick();\r\n     *   // Use usbStick for further operations\r\n     * } catch (error) {\r\n     *   console.error(error.message);\r\n     * }\r\n     */\r\n    constructor() {\r\n        if (typeof navigator === \"undefined\" || typeof navigator.usb === \"undefined\") {\r\n            throw new Error(\"WebUSB API is not available in this environment.\");\r\n        }\r\n\r\n        super();\r\n    }\r\n}\r\n","/**\r\n * A polyfill for `process.nextTick`, providing cross-platform compatibility.\r\n * In Node.js, it uses `process.nextTick`. In browsers, it falls back to\r\n * `setImmediate` if available, or `setTimeout` as a last resort.\r\n *\r\n * This function ensures that the provided callback function is executed asynchronously\r\n * after the current execution stack, similar to how `process.nextTick` works in Node.js.\r\n *\r\n * @param {() => void} fn - The callback function to execute asynchronously.\r\n *\r\n * @returns {void} No return value; the function is executed asynchronously.\r\n *\r\n * @example\r\n * nextTick(() => {\r\n *   console.log(\"This runs asynchronously after the current stack.\");\r\n * });\r\n */\r\nexport function nextTick(fn: () => void): void {\r\n    if (typeof process !== \"undefined\" && typeof process.nextTick === \"function\") {\r\n        // In Node.js, use process.nextTick\r\n        process.nextTick(fn);\r\n    } else if (typeof setImmediate === \"function\") {\r\n        // If setImmediate is available (some browsers, IE/Edge), use it\r\n        setImmediate(fn);\r\n    } else {\r\n        // Fallback for browsers and other environments: use setTimeout with 0 delay\r\n        setTimeout(fn, 0);\r\n    }\r\n}\r\n","import { EventEmitter } from \"events\";\r\nimport { SendCallback } from \"../types/sendCallback.js\";\r\nimport { Constants } from \"../types/constants.js\";\r\nimport { Messages } from \"../utils/messages.js\";\r\nimport { Status } from \"../types/status.js\";\r\nimport { USBDriverBase } from \"../types/usbDriverBase.js\";\r\nimport { nextTick } from \"../utils/customPolyfills.js\";\r\n\r\n/**\r\n * Abstract base class for sensors that communicates over a USB connection.\r\n * Extends EventEmitter to handle various events related to sensor data and status.\r\n */\r\nexport abstract class BaseSensor extends EventEmitter {\r\n    channel: number | undefined;\r\n    deviceId!: number;\r\n    transmissionType!: number;\r\n\r\n    private messageQueue: { msg: Uint8Array; cbk?: SendCallback }[] = [];\r\n\r\n    protected decodeDataCbk: ((data: DataView) => Promise<void>) | undefined;\r\n    protected statusCbk: ((status: Status) => Promise<boolean>) | undefined;\r\n\r\n    /**\r\n     * Abstract method to update the state of the sensor.\r\n     * Must be implemented by subclasses.\r\n     *\r\n     * @param {number} deviceId - The device ID to update.\r\n     * @param {Uint8Array} data - The data buffer containing the state information.\r\n     */\r\n    protected abstract updateState(deviceId: number, data: DataView): void;\r\n\r\n    /**\r\n     * Creates an instance of BaseSensor.\r\n     *\r\n     * @param {USBDriverBase} stick - The USB driver used for communication with the sensor.\r\n     */\r\n    constructor(private stick: USBDriverBase) {\r\n        super();\r\n        stick.on(\"read\", (data: Uint8Array) => {\r\n            this.handleEventMessages(data).catch((error) => {\r\n                console.error(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts scanning for devices of the specified type at a given frequency.\r\n     *\r\n     * @param {string} type - The type of device to scan for.\r\n     * @param {number} frequency - The frequency at which to scan.\r\n     *\r\n     * @throws Will throw an error if already attached or if the stick cannot scan.\r\n     */\r\n    protected async scan(type: string, frequency: number): Promise<void> {\r\n        if (this.channel !== undefined) {\r\n            throw new Error(\"Already attached\");\r\n        }\r\n\r\n        if (!this.stick.canScan) {\r\n            throw new Error(\"Stick cannot scan\");\r\n        }\r\n\r\n        const channel = 0;\r\n\r\n        const onStatus = async (status: Status) => {\r\n            switch (status.msg) {\r\n                case Constants.MESSAGE_RF:\r\n                    // Handle various message statuses\r\n                    switch (status.code) {\r\n                        case Constants.EVENT_CHANNEL_CLOSED:\r\n                        case Constants.EVENT_RX_FAIL_GO_TO_SEARCH:\r\n                            await this.write(Messages.unassignChannel(channel));\r\n                            return true;\r\n                        case Constants.EVENT_TRANSFER_TX_COMPLETED:\r\n                        case Constants.EVENT_TRANSFER_TX_FAILED:\r\n                        case Constants.EVENT_RX_FAIL:\r\n                        case Constants.INVALID_SCAN_TX_CHANNEL: {\r\n                            const mc = this.messageQueue.shift();\r\n                            if (mc && mc.cbk) {\r\n                                mc.cbk(status.code === Constants.EVENT_TRANSFER_TX_COMPLETED);\r\n                            }\r\n                            if (this.messageQueue.length) {\r\n                                await this.write(this.messageQueue[0].msg);\r\n                            }\r\n                            return true;\r\n                        }\r\n                        default:\r\n                            break;\r\n                    }\r\n                    break;\r\n                case Constants.MESSAGE_CHANNEL_ASSIGN:\r\n                    await this.write(Messages.setDevice(channel, 0, 0, 0));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_ID:\r\n                    await this.write(Messages.setFrequency(channel, frequency));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_FREQUENCY:\r\n                    await this.write(Messages.setRxExt());\r\n                    return true;\r\n                case Constants.MESSAGE_ENABLE_RX_EXT:\r\n                    await this.write(Messages.libConfig(channel, 0xe0));\r\n                    return true;\r\n                case Constants.MESSAGE_LIB_CONFIG:\r\n                    await this.write(Messages.openRxScan());\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_OPEN_RX_SCAN:\r\n                    nextTick(() => this.emit(\"attached\"));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_CLOSE:\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_UNASSIGN:\r\n                    this.statusCbk = undefined;\r\n                    this.channel = undefined;\r\n                    nextTick(() => this.emit(\"detached\"));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_ACKNOWLEDGED_DATA:\r\n                    return status.code === Constants.TRANSFER_IN_PROGRESS;\r\n                default:\r\n                    break;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        if (await this.stick.isScanning()) {\r\n            this.channel = channel;\r\n            this.deviceId = 0;\r\n            this.transmissionType = 0;\r\n\r\n            this.statusCbk = onStatus;\r\n\r\n            nextTick(() => this.emit(\"attached\"));\r\n        } else if (await this.stick.attach(this, true)) {\r\n            this.channel = channel;\r\n            this.deviceId = 0;\r\n            this.transmissionType = 0;\r\n\r\n            this.statusCbk = onStatus;\r\n\r\n            await this.write(Messages.assignChannel(channel, type));\r\n        } else {\r\n            const errorMessage = (await this.stick.canAttach()) ? \"Cannot attach: Device is not scanning, and an unknown error occurred during attachment.\" : \"Cannot attach: Maximum number of channels reached, unable to attach more sensors.\";\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches the sensor to a specific channel with the given parameters.\r\n     *\r\n     * @param {number} channel - The channel number to attach to.\r\n     * @param {string} type - The type of device.\r\n     * @param {number} deviceId - The device ID.\r\n     * @param {number} deviceType - The type of the device.\r\n     * @param {number} transmissionType - The transmission type.\r\n     * @param {number} timeout - The timeout value for the channel.\r\n     * @param {number} period - The period for communication.\r\n     * @param {number} frequency - The frequency for communication.\r\n     *\r\n     * @throws Will throw an error if already attached or if unable to attach.\r\n     */\r\n    protected async attachSensor(channel: number, type: string, deviceId: number, deviceType: number, transmissionType: number, timeout: number, period: number, frequency: number) {\r\n        if (this.channel !== undefined) {\r\n            throw new Error(\"Already attached\");\r\n        }\r\n\r\n        const attached = await this.stick.attach(this, false);\r\n        if (!attached) {\r\n            const errorMessage = (await this.stick.canAttach()) ? \"Cannot attach: Device is not in scanning mode or an unknown error occurred.\" : \"Cannot attach: Maximum number of channels reached, unable to attach more sensors.\";\r\n            throw new Error(errorMessage);\r\n        }\r\n\r\n        this.channel = channel;\r\n        this.deviceId = deviceId;\r\n        this.transmissionType = transmissionType;\r\n\r\n        const onStatus = async (status: Status) => {\r\n            switch (status.msg) {\r\n                case Constants.MESSAGE_RF:\r\n                    // Handle various message statuses\r\n                    switch (status.code) {\r\n                        case Constants.EVENT_CHANNEL_CLOSED:\r\n                        case Constants.EVENT_RX_FAIL_GO_TO_SEARCH:\r\n                            await this.write(Messages.unassignChannel(channel));\r\n                            return true;\r\n                        case Constants.EVENT_TRANSFER_TX_COMPLETED:\r\n                        case Constants.EVENT_TRANSFER_TX_FAILED:\r\n                        case Constants.EVENT_RX_FAIL:\r\n                        case Constants.INVALID_SCAN_TX_CHANNEL: {\r\n                            const mc = this.messageQueue.shift();\r\n                            if (mc && mc.cbk) {\r\n                                mc.cbk(status.code === Constants.EVENT_TRANSFER_TX_COMPLETED);\r\n                            }\r\n                            if (this.messageQueue.length) {\r\n                                await this.write(this.messageQueue[0].msg);\r\n                            }\r\n                            return true;\r\n                        }\r\n                        case Constants.EVENT_CHANNEL_COLLISION:\r\n                            return true;\r\n                        default:\r\n                            break;\r\n                    }\r\n                    break;\r\n                case Constants.MESSAGE_CHANNEL_ASSIGN:\r\n                    await this.write(Messages.setDevice(channel, deviceId, deviceType, transmissionType));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_ID:\r\n                    await this.write(Messages.searchChannel(channel, timeout));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_SEARCH_TIMEOUT:\r\n                    await this.write(Messages.setFrequency(channel, frequency));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_FREQUENCY:\r\n                    await this.write(Messages.setPeriod(channel, period));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_PERIOD:\r\n                    await this.write(Messages.libConfig(channel, 0xe0));\r\n                    return true;\r\n                case Constants.MESSAGE_LIB_CONFIG:\r\n                    await this.write(Messages.openChannel(channel));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_OPEN:\r\n                    nextTick(() => this.emit(\"attached\"));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_CLOSE:\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_UNASSIGN:\r\n                    this.statusCbk = undefined;\r\n                    this.channel = undefined;\r\n                    nextTick(() => this.emit(\"detached\"));\r\n                    return true;\r\n                case Constants.MESSAGE_CHANNEL_ACKNOWLEDGED_DATA:\r\n                    return status.code === Constants.TRANSFER_IN_PROGRESS;\r\n                default:\r\n                    break;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        this.statusCbk = onStatus;\r\n\r\n        await this.write(Messages.assignChannel(channel, type));\r\n    }\r\n\r\n    /**\r\n     * Detaches the sensor from its assigned channel and stops communication.\r\n     *\r\n     * @throws Will throw an error if there is an issue detaching.\r\n     */\r\n    public async detach() {\r\n        if (this.channel === undefined) {\r\n            return;\r\n        }\r\n        await this.write(Messages.closeChannel(this.channel));\r\n        const detached = await this.stick.detach(this);\r\n        if (!detached) {\r\n            throw new Error(\"Error on detaching\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends data to the USB device.\r\n     *\r\n     * @param {Uint8Array} data - The data buffer to send.\r\n     */\r\n    protected async write(data: Uint8Array): Promise<void> {\r\n        await this.stick.write(data);\r\n    }\r\n\r\n    /**\r\n     * Handles incoming event messages from the USB device.\r\n     *\r\n     * @private\r\n     * @param {Uint8Array} data - The data buffer containing the event message.\r\n     */\r\n    private async handleEventMessages(data: Uint8Array): Promise<void> {\r\n        const dataView = new DataView(data.buffer);\r\n        const messageId = dataView.getUint8(Messages.BUFFER_INDEX_MSG_TYPE);\r\n        const channel = dataView.getUint8(Messages.BUFFER_INDEX_CHANNEL_NUM);\r\n\r\n        if (channel === this.channel) {\r\n            if (messageId === Constants.MESSAGE_CHANNEL_EVENT) {\r\n                const status: Status = {\r\n                    msg: dataView.getUint8(Messages.BUFFER_INDEX_MSG_DATA),\r\n                    code: dataView.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1),\r\n                };\r\n\r\n                const handled = this.statusCbk && this.statusCbk(status);\r\n                if (!handled) {\r\n                    console.log(\r\n                        \"Unhandled event: \" +\r\n                            Array.from(data)\r\n                                .map((byte) => byte.toString(16))\r\n                                .join(\" \")\r\n                    );\r\n                    this.emit(\"eventData\", {\r\n                        message: dataView.getUint8(Messages.BUFFER_INDEX_MSG_DATA),\r\n                        code: dataView.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1),\r\n                    });\r\n                }\r\n            } else if (this.decodeDataCbk) {\r\n                await this.decodeDataCbk(dataView);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends data and optionally a callback to handle the result of the send operation.\r\n     *\r\n     * @param {Uint8Array} data - The data buffer to send.\r\n     * @param {SendCallback} [cbk] - Optional callback to handle the send result.\r\n     */\r\n    protected async send(data: Uint8Array, cbk?: SendCallback): Promise<void> {\r\n        this.messageQueue.push({ msg: data, cbk });\r\n        if (this.messageQueue.length === 1) {\r\n            await this.write(data);\r\n        }\r\n    }\r\n}\r\n","import { HeartRateScanner } from \"./heartRateScanner.js\";\r\nimport { HeartRateScanState } from \"./heartRateScanState.js\";\r\nimport { HeartRateSensor } from \"./heartRateSensor.js\";\r\nimport { HeartRateSensorState } from \"./heartRateSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\nexport enum PageState {\r\n    INIT_PAGE,\r\n    STD_PAGE,\r\n    EXT_PAGE,\r\n}\r\n\r\nexport type Page = {\r\n    oldPage: number;\r\n    pageState: PageState; // sets the state of the receiver - INIT, STD_PAGE, EXT_PAGE\r\n};\r\n\r\nconst TOGGLE_MASK = 0x80;\r\n\r\n/**\r\n * Updates the state of a Heart Rate sensor or scanner based on incoming data.\r\n * Decodes various pages of data to update the state, including operating time, manufacturer details,\r\n * battery status, heart rate data, and more.\r\n *\r\n * @param {HeartRateSensor | HeartRateScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {HeartRateSensorState | HeartRateScanState} state - The current state of the sensor or scanner.\r\n * @param {Page} page - The page information containing the current and old page number.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n *\r\n * @example\r\n * const sensor = new HeartRateSensor();\r\n * const state = new HeartRateSensorState(12345);\r\n * const page = { oldPage: 0, pageState: PageState.INIT_PAGE };\r\n * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n * updateState(sensor, state, page, dataBuffer);\r\n */\r\nexport function updateState(sensor: HeartRateSensor | HeartRateScanner, state: HeartRateSensorState | HeartRateScanState, page: Page, data: DataView): void {\r\n    const pageNum = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n    if (page.pageState === PageState.INIT_PAGE) {\r\n        page.pageState = PageState.STD_PAGE; // change the state to STD_PAGE and allow the checking of old and new pages\r\n    } else if (pageNum !== page.oldPage || page.pageState === PageState.EXT_PAGE) {\r\n        page.pageState = PageState.EXT_PAGE; // set the state to use the extended page format\r\n        switch (\r\n            pageNum & ~TOGGLE_MASK // Check the new pages and remove the toggle bit\r\n        ) {\r\n            case 1:\r\n                // Decode the cumulative operating time\r\n                state.OperatingTime = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n                state.OperatingTime |= data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2) << 8;\r\n                state.OperatingTime |= data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3) << 16;\r\n                state.OperatingTime *= 2;\r\n                break;\r\n            case 2:\r\n                // Decode the Manufacturer ID\r\n                state.ManId = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n                // Decode the 4-byte serial number\r\n                state.SerialNumber = state.DeviceId;\r\n                state.SerialNumber |= data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 2, true) << 16;\r\n                state.SerialNumber >>>= 0;\r\n                break;\r\n            case 3:\r\n                // Decode hardware version, software version, and model number\r\n                state.HwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n                state.SwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n                state.ModelNum = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n                break;\r\n            case 4:\r\n                // Decode the previous heart beat measurement time\r\n                state.PreviousBeat = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 2, true);\r\n                break;\r\n            case 5:\r\n                state.IntervalAverage = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n                state.IntervalMax = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n                state.SessionAverage = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n                break;\r\n            case 6:\r\n                state.SupportedFeatures = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n                state.EnabledFeatures = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n                break;\r\n            case 7: {\r\n                const batteryLevel = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n                const batteryFrac = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n                const batteryStatus = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n                if (batteryLevel !== 0xff) {\r\n                    state.BatteryLevel = batteryLevel;\r\n                }\r\n                state.BatteryVoltage = (batteryStatus & 0x0f) + batteryFrac / 256;\r\n                const batteryFlags = (batteryStatus & 0x70) >>> 4;\r\n                state.BatteryStatusBit = batteryFlags;\r\n                switch (batteryFlags) {\r\n                    case 1:\r\n                        state.BatteryStatus = \"New\";\r\n                        break;\r\n                    case 2:\r\n                        state.BatteryStatus = \"Good\";\r\n                        break;\r\n                    case 3:\r\n                        state.BatteryStatus = \"Ok\";\r\n                        break;\r\n                    case 4:\r\n                        state.BatteryStatus = \"Low\";\r\n                        break;\r\n                    case 5:\r\n                        state.BatteryStatus = \"Critical\";\r\n                        break;\r\n                    default:\r\n                        state.BatteryVoltage = undefined;\r\n                        state.BatteryStatus = \"Invalid\";\r\n                        break;\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    // Decode the last four bytes of the HRM format, the first byte of this message is the channel number\r\n    DecodeDefaultHRM(state, new DataView(data.buffer.slice(Messages.BUFFER_INDEX_MSG_DATA + 4)));\r\n    page.oldPage = pageNum;\r\n\r\n    sensor.emit(\"heartRateData\", state);\r\n}\r\n\r\n/**\r\n * Decodes the default Heart Rate Monitor (HRM) data from the buffer and updates the sensor state.\r\n *\r\n * @param {HeartRateSensorState | HeartRateScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} pucPayload - The buffer containing the HRM data.\r\n * @returns {void}\r\n *\r\n * @example\r\n * const state = new HeartRateSensorState(12345);\r\n * const hrmData = new Uint8Array([0x00, 0x01, 0x02, 0x03]); // Sample HRM data buffer\r\n * DecodeDefaultHRM(state, hrmData);\r\n */\r\nfunction DecodeDefaultHRM(state: HeartRateSensorState | HeartRateScanState, pucPayload: DataView): void {\r\n    // Decode the measurement time data (two bytes)\r\n    state.BeatTime = pucPayload.getUint16(0, true); // little-endian\r\n    // Decode the measurement count data\r\n    state.BeatCount = pucPayload.getUint8(2);\r\n    // Decode the computed heart rate data\r\n    state.ComputedHeartRate = pucPayload.getUint8(3);\r\n}\r\n","/**\r\n * Represents the state of a Heart Rate sensor.\r\n * This class holds the data fields associated with the state of a Heart Rate sensor,\r\n * including heart rate measurements, device details, and battery status.\r\n */\r\nexport class HeartRateSensorState {\r\n    /**\r\n     * Creates an instance of the HeartRateSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @example\r\n     * const sensorState = new HeartRateSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The time of the last beat event in milliseconds.\r\n     * @type {number | undefined}\r\n     */\r\n    BeatTime: number | undefined;\r\n\r\n    /**\r\n     * The cumulative count of beat events since the sensor started.\r\n     * @type {number | undefined}\r\n     */\r\n    BeatCount: number | undefined;\r\n\r\n    /**\r\n     * The computed heart rate in beats per minute (BPM).\r\n     * @type {number | undefined}\r\n     */\r\n    ComputedHeartRate: number | undefined;\r\n\r\n    /**\r\n     * The cumulative operating time of the sensor in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    OperatingTime?: number;\r\n\r\n    /**\r\n     * The manufacturer ID of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ManId?: number;\r\n\r\n    /**\r\n     * The serial number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SerialNumber?: number;\r\n\r\n    /**\r\n     * The hardware version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    HwVersion?: number;\r\n\r\n    /**\r\n     * The software version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SwVersion?: number;\r\n\r\n    /**\r\n     * The model number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ModelNum?: number;\r\n\r\n    /**\r\n     * The time of the previous beat measurement.\r\n     * @type {number | undefined}\r\n     */\r\n    PreviousBeat?: number;\r\n\r\n    /**\r\n     * The average heart rate over a certain interval.\r\n     * @type {number | undefined}\r\n     */\r\n    IntervalAverage?: number;\r\n\r\n    /**\r\n     * The maximum heart rate over a certain interval.\r\n     * @type {number | undefined}\r\n     */\r\n    IntervalMax?: number;\r\n\r\n    /**\r\n     * The average heart rate over the current session.\r\n     * @type {number | undefined}\r\n     */\r\n    SessionAverage?: number;\r\n\r\n    /**\r\n     * The supported features of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SupportedFeatures?: number;\r\n\r\n    /**\r\n     * The enabled features of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    EnabledFeatures?: number;\r\n\r\n    /**\r\n     * The battery level of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    BatteryLevel?: number;\r\n\r\n    /**\r\n     * The battery voltage of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    BatteryVoltage?: number;\r\n\r\n    /**\r\n     * The battery status of the sensor.\r\n     * Can be \"New\", \"Good\", \"Ok\", \"Low\", \"Critical\", or \"Invalid\".\r\n     * @type {\"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\" | undefined}\r\n     */\r\n    BatteryStatus?: \"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\";\r\n\r\n    /**\r\n     * The battery status bit of the sensor.\r\n     */\r\n    BatteryStatusBit?: number;\r\n}\r\n","import { HeartRateSensorState } from \"./heartRateSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Heart Rate sensor during scanning.\r\n * Extends the HeartRateSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class HeartRateScanState extends HeartRateSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value for the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","import { BaseSensor } from \"./baseSensor.js\";\r\n\r\n/**\r\n * Abstract base class for ANT+ sensors, extending the functionality of the BaseSensor class.\r\n * This class provides methods to scan and attach ANT+ sensors with specific configurations.\r\n */\r\nexport abstract class AntPlusBaseSensor extends BaseSensor {\r\n    /**\r\n     * Initiates a scan for ANT+ sensors of a specific type.\r\n     *\r\n     * @protected\r\n     * @param {string} type - The type of sensor to scan for.\r\n     * @returns {Promise<void>} A promise that resolves when the scan is complete.\r\n     *\r\n     * @example\r\n     * // Example usage:\r\n     * const sensor = new AntPlusSensor();\r\n     * sensor.scan('heartRate');\r\n     */\r\n    protected async scan(type: string): Promise<void> {\r\n        return await super.scan(type, 57);\r\n    }\r\n\r\n    /**\r\n     * Attaches to a specific ANT+ sensor by configuring the channel, type, device ID, device type, transmission type, timeout, and period.\r\n     *\r\n     * @protected\r\n     * @param {number} channel - The channel number to use for communication with the sensor.\r\n     * @param {string} type - The type of sensor to attach to.\r\n     * @param {number} deviceId - The unique ID of the device to attach to.\r\n     * @param {number} deviceType - The type of the device (e.g., heart rate monitor, speed sensor).\r\n     * @param {number} transmissionType - The transmission type used by the sensor.\r\n     * @param {number} timeout - The timeout period for communication in seconds.\r\n     * @param {number} period - The communication period with the sensor in milliseconds.\r\n     * @returns {Promise<void>} A promise that resolves when the sensor is successfully attached.\r\n     *\r\n     * @example\r\n     * // Example usage:\r\n     * const sensor = new AntPlusSensor();\r\n     * sensor.attachSensor(1, 'heartRate', 12345, 120, 5, 60, 8070);\r\n     */\r\n    protected async attachSensor(channel: number, type: string, deviceId: number, deviceType: number, transmissionType: number, timeout: number, period: number): Promise<void> {\r\n        return await super.attachSensor(channel, type, deviceId, deviceType, transmissionType, timeout, period, 57);\r\n    }\r\n}\r\n","import { AntPlusBaseSensor } from \"./antPlusBaseSensor.js\";\r\nimport { Constants } from \"../types/constants.js\";\r\nimport { Messages } from \"../utils/messages.js\";\r\nimport { USBDriverBase } from \"../types/usbDriverBase.js\";\r\n\r\n/**\r\n * Abstract base class for managing a specific ANT+ sensor, extending the functionality\r\n * of the AntPlusBaseSensor class. Provides methods for attaching sensors and decoding data.\r\n */\r\nexport abstract class AntPlusSensor extends AntPlusBaseSensor {\r\n    /**\r\n     * Constructs an instance of the AntPlusSensor class.\r\n     *\r\n     * @param {USBDriverBase} stick - The USB driver instance used for communication with the ANT+ stick.\r\n     */\r\n    constructor(stick: USBDriverBase) {\r\n        super(stick);\r\n        this.decodeDataCbk = this.decodeData.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Unsupported method for scanning sensors. Throws an error when called.\r\n     *\r\n     * @protected\r\n     * @throws {Error} Always throws an error indicating that scanning is unsupported.\r\n     */\r\n    protected scan(): Promise<void> {\r\n        throw new Error(\"scanning unsupported\");\r\n    }\r\n\r\n    /**\r\n     * Attaches to a specific ANT+ sensor by configuring the channel, type, device ID, device type,\r\n     * transmission type, timeout, and period.\r\n     *\r\n     * @protected\r\n     * @param {number} channel - The channel number to use for communication with the sensor.\r\n     * @param {string} type - The type of sensor to attach to.\r\n     * @param {number} deviceId - The unique ID of the device to attach to.\r\n     * @param {number} deviceType - The type of the device (e.g., heart rate monitor, speed sensor).\r\n     * @param {number} transmissionType - The transmission type used by the sensor.\r\n     * @param {number} timeout - The timeout period for communication in seconds.\r\n     * @param {number} period - The communication period with the sensor in milliseconds.\r\n     * @returns {Promise<void>} A promise that resolves when the sensor is successfully attached.\r\n     *\r\n     * @example\r\n     * // Example usage:\r\n     * const sensor = new AntPlusSensor();\r\n     * sensor.attachSensor(1, 'heartRate', 12345, 120, 5, 60, 8070);\r\n     */\r\n    protected async attachSensor(channel: number, type: string, deviceId: number, deviceType: number, transmissionType: number, timeout: number, period: number): Promise<void> {\r\n        return await super.attachSensor(channel, type, deviceId, deviceType, transmissionType, timeout, period);\r\n    }\r\n\r\n    /**\r\n     * Decodes the incoming data from the ANT+ sensor and updates the sensor state.\r\n     *\r\n     * @private\r\n     * @param {DataView} data - The raw data buffer received from the ANT+ sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * // Example usage:\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * decodeData(dataBuffer);\r\n     */\r\n    private async decodeData(data: DataView): Promise<void> {\r\n        switch (data.getUint8(Messages.BUFFER_INDEX_MSG_TYPE)) {\r\n            case Constants.MESSAGE_CHANNEL_BROADCAST_DATA:\r\n            case Constants.MESSAGE_CHANNEL_ACKNOWLEDGED_DATA:\r\n            case Constants.MESSAGE_CHANNEL_BURST_DATA:\r\n                if (this.deviceId === 0 && this.channel != undefined) {\r\n                    await this.write(Messages.requestMessage(this.channel, Constants.MESSAGE_CHANNEL_ID));\r\n                }\r\n                this.updateState(this.deviceId, data);\r\n                break;\r\n            case Constants.MESSAGE_CHANNEL_ID:\r\n                this.deviceId = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA, true);\r\n                this.transmissionType = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#526_tab\r\n * Spec sheet: https://www.thisisant.com/resources/heart-rate-monitor/\r\n */\r\n\r\nimport { Page, PageState, updateState } from \"./heartRateUtils.js\";\r\nimport { HeartRateSensorState } from \"./heartRateSensorState.js\";\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\n\r\n/**\r\n * Represents a Heart Rate sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to heart rate monitoring.\r\n *\r\n * @category Sensors\r\n */\r\nexport class HeartRateSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Heart Rate sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 120;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new HeartRateSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, HeartRateSensor.deviceType, 0, 255, 8070);\r\n        this.state = new HeartRateSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * The current state of the Heart Rate sensor.\r\n     * @private\r\n     * @type {HeartRateSensorState}\r\n     */\r\n    private state!: HeartRateSensorState;\r\n\r\n    /**\r\n     * Represents the page information used in communication with the sensor.\r\n     * @private\r\n     * @type {Page}\r\n     * @default { oldPage: -1, pageState: PageState.INIT_PAGE }\r\n     */\r\n    private page: Page = {\r\n        oldPage: -1,\r\n        pageState: PageState.INIT_PAGE,\r\n    };\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, this.page, data);\r\n    }\r\n}\r\n","import { AntPlusBaseSensor } from \"./antPlusBaseSensor.js\";\r\nimport { Constants } from \"../types/constants.js\";\r\nimport { Messages } from \"../utils/messages.js\";\r\nimport { USBDriverBase } from \"../types/usbDriverBase.js\";\r\n\r\n/**\r\n * Abstract base class for scanning and decoding data from ANT+ sensors.\r\n * This class provides methods to scan for sensors, handle sensor data, and manage sensor states.\r\n */\r\nexport abstract class AntPlusScanner extends AntPlusBaseSensor {\r\n    /**\r\n     * Returns the type of device being scanned for.\r\n     *\r\n     * @protected\r\n     * @returns {number} The numeric code representing the device type.\r\n     */\r\n    protected abstract deviceType(): number;\r\n\r\n    /**\r\n     * Creates a new state for the device if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the device.\r\n     */\r\n    protected abstract createStateIfNew(deviceId: number): void;\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and the signal threshold for the specified device.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     */\r\n    protected abstract updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void;\r\n\r\n    /**\r\n     * Constructs an instance of the AntPlusScanner class.\r\n     *\r\n     * @param {USBDriverBase} stick - The USB driver instance used for communication with the ANT+ stick.\r\n     */\r\n    constructor(stick: USBDriverBase) {\r\n        super(stick);\r\n        this.decodeDataCbk = this.decodeData.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Initiates a scan for ANT+ sensors by receiving broadcast messages.\r\n     *\r\n     * @public\r\n     * @returns {Promise<void>} A promise that resolves when the scanning process is complete.\r\n     *\r\n     * @example\r\n     * // Example usage:\r\n     * const scanner = new AntPlusScanner();\r\n     * scanner.scan();\r\n     */\r\n    public async scan(): Promise<void> {\r\n        return await super.scan(\"receive\");\r\n    }\r\n\r\n    /**\r\n     * Unsupported method for attaching to a sensor. Throws an error when called.\r\n     *\r\n     * @protected\r\n     * @throws {Error} Always throws an error indicating that attaching is unsupported.\r\n     */\r\n    protected attach() {\r\n        throw new Error(\"attach unsupported\");\r\n    }\r\n\r\n    /**\r\n     * Unsupported method for sending data to a sensor. Throws an error when called.\r\n     *\r\n     * @protected\r\n     * @throws {Error} Always throws an error indicating that sending is unsupported.\r\n     */\r\n    protected send(): Promise<void> {\r\n        throw new Error(\"send unsupported\");\r\n    }\r\n\r\n    /**\r\n     * Decodes the incoming data from the ANT+ sensors and updates the sensor state.\r\n     *\r\n     * @private\r\n     * @param {DataView} data - The raw data buffer received from the ANT+ sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * // Example usage:\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * decodeData(dataBuffer);\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/require-await\r\n    private async decodeData(data: DataView): Promise<void> {\r\n        if (data.byteLength <= Messages.BUFFER_INDEX_EXT_MSG_BEGIN + 3 || !(data.getUint8(Messages.BUFFER_INDEX_EXT_MSG_BEGIN) & 0x80)) {\r\n            const bytesArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n            console.log(\r\n                \"wrong message format\",\r\n                Array.from(bytesArray)\r\n                    .map((byte) => byte.toString(16))\r\n                    .join(\" \")\r\n            );\r\n            return;\r\n        }\r\n\r\n        const deviceId = data.getUint16(Messages.BUFFER_INDEX_EXT_MSG_BEGIN + 1, true);\r\n        console.log(this.deviceId);\r\n        const deviceType = data.getUint8(Messages.BUFFER_INDEX_EXT_MSG_BEGIN + 3);\r\n\r\n        if (deviceType !== this.deviceType()) {\r\n            return;\r\n        }\r\n\r\n        this.createStateIfNew(deviceId);\r\n\r\n        // Check if the RSSI and threshold should be updated\r\n        if (data.getUint8(Messages.BUFFER_INDEX_EXT_MSG_BEGIN) & 0x40) {\r\n            if (data.getUint8(Messages.BUFFER_INDEX_EXT_MSG_BEGIN + 5) === 0x20) {\r\n                const rssi = data.getInt8(Messages.BUFFER_INDEX_EXT_MSG_BEGIN + 6);\r\n                const threshold = data.getInt8(Messages.BUFFER_INDEX_EXT_MSG_BEGIN + 7);\r\n                this.updateRssiAndThreshold(deviceId, rssi, threshold);\r\n            }\r\n        }\r\n\r\n        // Handle different message types\r\n        switch (data.getUint8(Messages.BUFFER_INDEX_MSG_TYPE)) {\r\n            case Constants.MESSAGE_CHANNEL_BROADCAST_DATA:\r\n            case Constants.MESSAGE_CHANNEL_ACKNOWLEDGED_DATA:\r\n            case Constants.MESSAGE_CHANNEL_BURST_DATA:\r\n                this.updateState(deviceId, data);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n","import { Page, PageState, updateState } from \"./heartRateUtils.js\";\r\nimport { HeartRateScanState } from \"./heartRateScanState.js\";\r\nimport { HeartRateSensor } from \"./heartRateSensor.js\";\r\nimport { AntPlusScanner } from \"../antPlusScanner.js\";\r\n\r\n/**\r\n * Represents a scanner for Heart Rate sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple Heart Rate sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class HeartRateScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Heart Rate sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Heart Rate sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return HeartRateSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Heart Rate sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: HeartRateScanState }}\r\n     */\r\n    private states: { [id: number]: HeartRateScanState } = {};\r\n\r\n    /**\r\n     * A dictionary to store page information for each detected Heart Rate sensor by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: Page }}\r\n     */\r\n    private pages: { [id: number]: Page } = {};\r\n\r\n    /**\r\n     * Creates a new state entry and page information for a sensor if they do not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state and page info for device ID 12345 if they do not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new HeartRateScanState(deviceId);\r\n        }\r\n\r\n        if (!this.pages[deviceId]) {\r\n            this.pages[deviceId] = { oldPage: -1, pageState: PageState.INIT_PAGE };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {Uint8Array} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], this.pages[deviceId], data);\r\n    }\r\n}\r\n","import { StrideSpeedDistanceScanner } from \"./strideSpeedDistanceScanner.js\";\r\nimport { StrideSpeedDistanceScanState } from \"./strideSpeedDistanceScanState.js\";\r\nimport { StrideSpeedDistanceSensor } from \"./strideSpeedDistanceSensor.js\";\r\nimport { StrideSpeedDistanceSensorState } from \"./strideSpeedDistanceSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\n/**\r\n * Updates the state of a Stride-Based Speed and Distance Monitor (SDM) sensor or scanner\r\n * based on the data received from the sensor.\r\n *\r\n * @param {StrideSpeedDistanceSensor | StrideSpeedDistanceScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {StrideSpeedDistanceSensorState | StrideSpeedDistanceScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n *\r\n * @example\r\n * const sensor = new StrideSpeedDistanceSensor();\r\n * const state = new StrideSpeedDistanceSensorState(12345);\r\n * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n * updateState(sensor, state, dataBuffer);\r\n */\r\nexport function updateState(sensor: StrideSpeedDistanceSensor | StrideSpeedDistanceScanner, state: StrideSpeedDistanceSensorState | StrideSpeedDistanceScanState, data: DataView) {\r\n    const page = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n\r\n    if (page === 1) {\r\n        state.TimeFractional = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n        state.TimeInteger = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n        state.DistanceInteger = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n        state.DistanceFractional = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4) >>> 4;\r\n        state.SpeedInteger = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4) & 0x0f;\r\n        state.SpeedFractional = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 5);\r\n        state.StrideCount = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n        state.UpdateLatency = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n    } else if (page >= 2 && page <= 15) {\r\n        state.CadenceInteger = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n        state.CadenceFractional = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4) >>> 4;\r\n        state.SpeedInteger = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4) & 0x0f;\r\n        state.SpeedFractional = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 5);\r\n        state.Status = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n        switch (page) {\r\n            case 3:\r\n                state.Calories = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    sensor.emit(\"ssddata\", state);\r\n    sensor.emit(\"ssdData\", state);\r\n}\r\n","/**\r\n * Represents the state of a Stride-Based Speed and Distance Monitor (SDM) sensor.\r\n * This class holds the data fields associated with the SDM sensor's state, including device ID,\r\n * speed, distance, cadence, and other relevant metrics.\r\n */\r\nexport class StrideSpeedDistanceSensorState {\r\n    /**\r\n     * Creates an instance of the StrideSpeedDistanceSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @example\r\n     * const sensorState = new StrideSpeedDistanceSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The fractional part of the elapsed time in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    TimeFractional: number | undefined;\r\n\r\n    /**\r\n     * The integer part of the elapsed time in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    TimeInteger: number | undefined;\r\n\r\n    /**\r\n     * The integer part of the total distance traveled in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    DistanceInteger: number | undefined;\r\n\r\n    /**\r\n     * The fractional part of the total distance traveled in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    DistanceFractional: number | undefined;\r\n\r\n    /**\r\n     * The integer part of the speed in meters per second.\r\n     * @type {number | undefined}\r\n     */\r\n    SpeedInteger: number | undefined;\r\n\r\n    /**\r\n     * The fractional part of the speed in meters per second.\r\n     * @type {number | undefined}\r\n     */\r\n    SpeedFractional: number | undefined;\r\n\r\n    /**\r\n     * The total number of strides counted.\r\n     * @type {number | undefined}\r\n     */\r\n    StrideCount: number | undefined;\r\n\r\n    /**\r\n     * The latency in milliseconds between updates.\r\n     * @type {number | undefined}\r\n     */\r\n    UpdateLatency: number | undefined;\r\n\r\n    /**\r\n     * The integer part of the cadence in strides per minute.\r\n     * @type {number | undefined}\r\n     */\r\n    CadenceInteger: number | undefined;\r\n\r\n    /**\r\n     * The fractional part of the cadence in strides per minute.\r\n     * @type {number | undefined}\r\n     */\r\n    CadenceFractional: number | undefined;\r\n\r\n    /**\r\n     * The status of the sensor, represented by a numeric value.\r\n     * @type {number | undefined}\r\n     */\r\n    Status: number | undefined;\r\n\r\n    /**\r\n     * The total calories burned, if available.\r\n     * @type {number | undefined}\r\n     */\r\n    Calories: number | undefined;\r\n}\r\n","import { StrideSpeedDistanceSensorState } from \"./strideSpeedDistanceSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Stride-Based Speed and Distance Monitor (SDM) sensor during scanning.\r\n * Extends the StrideSpeedDistanceSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and the signal threshold.\r\n */\r\nexport class StrideSpeedDistanceScanState extends StrideSpeedDistanceSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#528_tab\r\n * Spec sheet: https://www.thisisant.com/resources/stride-based-speed-and-distance-monitor/\r\n */\r\n\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\nimport { updateState } from \"./strideSpeedDistanceUtils.js\";\r\nimport { StrideSpeedDistanceSensorState } from \"./strideSpeedDistanceSensorState.js\";\r\n\r\n/**\r\n * Represents a Stride-Based Speed and Distance Monitor (SDM) sensor.\r\n * This class extends the AntPlusSensor class to provide specific functionality for handling SDM sensor data.\r\n *\r\n * @category Sensors\r\n */\r\nexport class StrideSpeedDistanceSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Stride-Based Speed and Distance Monitor (SDM) sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 124;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new StrideSpeedDistanceSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, StrideSpeedDistanceSensor.deviceType, 0, 255, 8134);\r\n        this.state = new StrideSpeedDistanceSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * The current state of the Stride-Based Speed and Distance Monitor sensor.\r\n     * @private\r\n     * @type {StrideSpeedDistanceSensorState}\r\n     */\r\n    private state!: StrideSpeedDistanceSensorState;\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView) {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n}\r\n","import { AntPlusScanner } from \"../antPlusScanner.js\";\r\nimport { updateState } from \"./strideSpeedDistanceUtils.js\";\r\nimport { StrideSpeedDistanceScanState } from \"./strideSpeedDistanceScanState.js\";\r\nimport { StrideSpeedDistanceSensor } from \"./strideSpeedDistanceSensor.js\";\r\n\r\n/**\r\n * Represents a scanner for Stride-Based Speed and Distance Monitor (SDM) sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple SDM sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class StrideSpeedDistanceScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Stride-Based Speed and Distance Monitor sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for SDM sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return StrideSpeedDistanceSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected SDM sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: StrideSpeedDistanceScanState }}\r\n     */\r\n    private states: { [id: number]: StrideSpeedDistanceScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new StrideSpeedDistanceScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { SpeedCadenceScanner } from \"./speedCadenceScanner.js\";\r\nimport { SpeedCadenceScanState } from \"./speedCadenceScanState.js\";\r\nimport { SpeedCadenceSensor } from \"./speedCadenceSensor.js\";\r\nimport { SpeedCadenceSensorState } from \"./speedCadenceSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\n/**\r\n * Updates the state of a Speed and Cadence sensor or scanner based on the incoming data.\r\n * Calculates the cadence and speed based on the revolution counts and event times provided in the data buffer.\r\n *\r\n * @param {SpeedCadenceSensor | SpeedCadenceScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {SpeedCadenceSensorState | SpeedCadenceScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n *\r\n * @example\r\n * const sensor = new SpeedCadenceSensor();\r\n * const state = new SpeedCadenceSensorState(12345);\r\n * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n * updateState(sensor, state, dataBuffer);\r\n */\r\nexport function updateState(sensor: SpeedCadenceSensor | SpeedCadenceScanner, state: SpeedCadenceSensorState | SpeedCadenceScanState, data: DataView) {\r\n    // Get old state for calculating cumulative values\r\n    const oldCadenceTime = state.CadenceEventTime ?? 0;\r\n    const oldCadenceCount = state.CumulativeCadenceRevolutionCount ?? 0;\r\n    const oldSpeedTime = state.SpeedEventTime ?? 0;\r\n    const oldSpeedCount = state.CumulativeSpeedRevolutionCount ?? 0;\r\n\r\n    let cadenceTime = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA, true);\r\n    let cadenceCount = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 2, true);\r\n    let speedEventTime = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n    let speedRevolutionCount = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n\r\n    if (cadenceTime !== oldCadenceTime) {\r\n        state.CadenceEventTime = cadenceTime;\r\n        state.CumulativeCadenceRevolutionCount = cadenceCount;\r\n\r\n        if (oldCadenceTime > cadenceTime) {\r\n            // Hit rollover value\r\n            cadenceTime += 1024 * 64;\r\n        }\r\n\r\n        if (oldCadenceCount > cadenceCount) {\r\n            // Hit rollover value\r\n            cadenceCount += 1024 * 64;\r\n        }\r\n\r\n        const cadence = (60 * (cadenceCount - oldCadenceCount) * 1024) / (cadenceTime - oldCadenceTime);\r\n        if (!isNaN(cadence)) {\r\n            state.CalculatedCadence = cadence;\r\n            sensor.emit(\"cadenceData\", state);\r\n        }\r\n    }\r\n\r\n    if (speedEventTime !== oldSpeedTime) {\r\n        state.SpeedEventTime = speedEventTime;\r\n        state.CumulativeSpeedRevolutionCount = speedRevolutionCount;\r\n\r\n        if (oldSpeedTime > speedEventTime) {\r\n            // Hit rollover value\r\n            speedEventTime += 1024 * 64;\r\n        }\r\n\r\n        if (oldSpeedCount > speedRevolutionCount) {\r\n            // Hit rollover value\r\n            speedRevolutionCount += 1024 * 64;\r\n        }\r\n\r\n        const distance = sensor.wheelCircumference * (speedRevolutionCount - oldSpeedCount);\r\n        state.CalculatedDistance = distance;\r\n\r\n        // Calculate speed in m/sec\r\n        const speed = (distance * 1024) / (speedEventTime - oldSpeedTime);\r\n        if (!isNaN(speed)) {\r\n            state.CalculatedSpeed = speed;\r\n            sensor.emit(\"speedData\", state);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Represents the state of a Speed and Cadence sensor.\r\n * This class holds the data fields associated with the state of a Speed and Cadence sensor, including\r\n * cadence, speed, distance, and event times.\r\n */\r\nexport class SpeedCadenceSensorState {\r\n    /**\r\n     * Creates an instance of the SpeedCadenceSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @example\r\n     * const sensorState = new SpeedCadenceSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The time of the last cadence event in seconds, measured as a fractional part.\r\n     * @type {number | undefined}\r\n     */\r\n    CadenceEventTime: number | undefined;\r\n\r\n    /**\r\n     * The cumulative count of cadence revolutions since the sensor started.\r\n     * @type {number | undefined}\r\n     */\r\n    CumulativeCadenceRevolutionCount: number | undefined;\r\n\r\n    /**\r\n     * The time of the last speed event in seconds, measured as a fractional part.\r\n     * @type {number | undefined}\r\n     */\r\n    SpeedEventTime: number | undefined;\r\n\r\n    /**\r\n     * The cumulative count of speed revolutions since the sensor started.\r\n     * @type {number | undefined}\r\n     */\r\n    CumulativeSpeedRevolutionCount: number | undefined;\r\n\r\n    /**\r\n     * The calculated cadence in revolutions per minute (RPM).\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedCadence: number | undefined;\r\n\r\n    /**\r\n     * The calculated distance traveled in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedDistance: number | undefined;\r\n\r\n    /**\r\n     * The calculated speed in meters per second (m/s).\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedSpeed: number | undefined;\r\n}\r\n","import { SpeedCadenceSensorState } from \"./speedCadenceSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Speed and Cadence sensor during scanning.\r\n * Extends the SpeedCadenceSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class SpeedCadenceScanState extends SpeedCadenceSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#523_tab\r\n * Spec sheet: https://www.thisisant.com/resources/bicycle-speed-and-cadence/\r\n */\r\n\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\nimport { updateState } from \"./speedCadenceUtils.js\";\r\nimport { SpeedCadenceSensorState } from \"./speedCadenceSensorState.js\";\r\n\r\n/**\r\n * Represents a Bicycle Speed and Cadence sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to speed and cadence.\r\n *\r\n * @category Sensors\r\n */\r\nexport class SpeedCadenceSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Bicycle Speed and Cadence sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 0x79;\r\n\r\n    /**\r\n     * The wheel circumference in meters, used to calculate speed.\r\n     * @type {number}\r\n     * @default 2.199\r\n     */\r\n    wheelCircumference: number = 2.199; // default 70cm wheel\r\n\r\n    /**\r\n     * Sets the wheel circumference for speed calculation.\r\n     *\r\n     * @public\r\n     * @param {number} wheelCircumference - The wheel circumference in meters.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new SpeedCadenceSensor();\r\n     * sensor.setWheelCircumference(2.105); // Sets the wheel circumference to 2.105 meters\r\n     */\r\n    public setWheelCircumference(wheelCircumference: number) {\r\n        this.wheelCircumference = wheelCircumference;\r\n    }\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new SpeedCadenceSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, SpeedCadenceSensor.deviceType, 0, 255, 8086);\r\n        this.state = new SpeedCadenceSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * The current state of the Bicycle Speed and Cadence sensor.\r\n     * @private\r\n     * @type {SpeedCadenceSensorState}\r\n     */\r\n    private state!: SpeedCadenceSensorState;\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView) {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n}\r\n","import { AntPlusScanner } from \"../antPlusScanner.js\";\r\nimport { updateState } from \"./speedCadenceUtils.js\";\r\nimport { SpeedCadenceScanState } from \"./speedCadenceScanState.js\";\r\nimport { SpeedCadenceSensor } from \"./speedCadenceSensor.js\";\r\n\r\n/**\r\n * Represents a scanner for Speed and Cadence sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple Speed and Cadence sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class SpeedCadenceScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Speed and Cadence sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Speed and Cadence sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return SpeedCadenceSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * The wheel circumference in meters, used to calculate speed.\r\n     * @type {number}\r\n     * @default 2.199\r\n     */\r\n    wheelCircumference: number = 2.199; // default 70cm wheel\r\n\r\n    /**\r\n     * Sets the wheel circumference for speed calculation.\r\n     *\r\n     * @public\r\n     * @param {number} wheelCircumference - The wheel circumference in meters.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const scanner = new SpeedCadenceScanner();\r\n     * scanner.setWheelCircumference(2.105); // Sets the wheel circumference to 2.105 meters\r\n     */\r\n    public setWheelCircumference(wheelCircumference: number): void {\r\n        this.wheelCircumference = wheelCircumference;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Speed and Cadence sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: SpeedCadenceScanState }}\r\n     */\r\n    private states: { [id: number]: SpeedCadenceScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new SpeedCadenceScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { SpeedScanner } from \"./speedScanner.js\";\r\nimport { SpeedScanState } from \"./speedScanState.js\";\r\nimport { SpeedSensor } from \"./speedSensor.js\";\r\nimport { SpeedSensorState } from \"./speedSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\nconst TOGGLE_MASK = 0x80;\r\n\r\n/**\r\n * Updates the state of a Speed sensor or scanner based on the incoming data.\r\n * Decodes various pages of data to update the state, including cumulative operating time,\r\n * manufacturer details, hardware and software versions, battery status, motion status, and speed.\r\n *\r\n * @param {SpeedSensor | SpeedScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {SpeedSensorState | SpeedScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n * @example\r\n * const sensor = new SpeedSensor();\r\n * const state = new SpeedSensorState(12345);\r\n * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n * updateState(sensor, state, dataBuffer);\r\n */\r\nexport function updateState(sensor: SpeedSensor | SpeedScanner, state: SpeedSensorState | SpeedScanState, data: DataView) {\r\n    const pageNum = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n    switch (\r\n        pageNum & ~TOGGLE_MASK // Check the new pages and remove the toggle bit\r\n    ) {\r\n        case 1:\r\n            // Decode the cumulative operating time\r\n            state.OperatingTime = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            state.OperatingTime |= data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2) << 8;\r\n            state.OperatingTime |= data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3) << 16;\r\n            state.OperatingTime *= 2;\r\n            break;\r\n        case 2:\r\n            // Decode the Manufacturer ID\r\n            state.ManId = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            // Decode the 4-byte serial number\r\n            state.SerialNumber = state.DeviceId;\r\n            state.SerialNumber |= data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 2, true) << 16;\r\n            state.SerialNumber >>>= 0;\r\n            break;\r\n        case 3:\r\n            // Decode hardware version, software version, and model number\r\n            state.HwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            state.SwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            state.ModelNum = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            break;\r\n        case 4: {\r\n            // Decode battery status\r\n            const batteryFrac = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const batteryStatus = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            state.BatteryVoltage = (batteryStatus & 0x0f) + batteryFrac / 256;\r\n            const batteryFlags = (batteryStatus & 0x70) >>> 4;\r\n            state.BatteryStatusBit = batteryFlags;\r\n            switch (batteryFlags) {\r\n                case 1:\r\n                    state.BatteryStatus = \"New\";\r\n                    break;\r\n                case 2:\r\n                    state.BatteryStatus = \"Good\";\r\n                    break;\r\n                case 3:\r\n                    state.BatteryStatus = \"Ok\";\r\n                    break;\r\n                case 4:\r\n                    state.BatteryStatus = \"Low\";\r\n                    break;\r\n                case 5:\r\n                    state.BatteryStatus = \"Critical\";\r\n                    break;\r\n                default:\r\n                    state.BatteryVoltage = undefined;\r\n                    state.BatteryStatus = \"Invalid\";\r\n                    break;\r\n            }\r\n            break;\r\n        }\r\n        case 5:\r\n            // Decode motion status\r\n            state.Motion = (data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1) & 0x01) === 0x01;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Get old state for calculating cumulative values\r\n    const oldSpeedTime = state.SpeedEventTime ?? 0;\r\n    const oldSpeedCount = state.CumulativeSpeedRevolutionCount ?? 0;\r\n\r\n    let speedEventTime = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n    let speedRevolutionCount = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n\r\n    if (speedEventTime !== oldSpeedTime) {\r\n        state.SpeedEventTime = speedEventTime;\r\n        state.CumulativeSpeedRevolutionCount = speedRevolutionCount;\r\n\r\n        if (oldSpeedTime > speedEventTime) {\r\n            // Hit rollover value\r\n            speedEventTime += 1024 * 64;\r\n        }\r\n\r\n        if (oldSpeedCount > speedRevolutionCount) {\r\n            // Hit rollover value\r\n            speedRevolutionCount += 1024 * 64;\r\n        }\r\n\r\n        const distance = sensor.wheelCircumference * (speedRevolutionCount - oldSpeedCount);\r\n        state.CalculatedDistance = distance;\r\n\r\n        // Calculate speed in m/sec\r\n        const speed = (distance * 1024) / (speedEventTime - oldSpeedTime);\r\n        if (!isNaN(speed)) {\r\n            state.CalculatedSpeed = speed;\r\n            sensor.emit(\"speedData\", state);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Represents the state of a Speed sensor.\r\n * This class holds the data fields associated with the state of a Speed sensor, including\r\n * speed, distance, event times, and various sensor-specific details.\r\n */\r\nexport class SpeedSensorState {\r\n    /**\r\n     * Creates an instance of the SpeedSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @example\r\n     * const sensorState = new SpeedSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The time of the last speed event in seconds, measured as a fractional part.\r\n     * @type {number | undefined}\r\n     */\r\n    SpeedEventTime: number | undefined;\r\n\r\n    /**\r\n     * The cumulative count of speed revolutions since the sensor started.\r\n     * @type {number | undefined}\r\n     */\r\n    CumulativeSpeedRevolutionCount: number | undefined;\r\n\r\n    /**\r\n     * The calculated distance traveled in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedDistance: number | undefined;\r\n\r\n    /**\r\n     * The calculated speed in meters per second (m/s).\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedSpeed: number | undefined;\r\n\r\n    /**\r\n     * The cumulative operating time of the sensor in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    OperatingTime?: number;\r\n\r\n    /**\r\n     * The manufacturer ID of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ManId?: number;\r\n\r\n    /**\r\n     * The serial number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SerialNumber?: number;\r\n\r\n    /**\r\n     * The hardware version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    HwVersion?: number;\r\n\r\n    /**\r\n     * The software version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SwVersion?: number;\r\n\r\n    /**\r\n     * The model number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ModelNum?: number;\r\n\r\n    /**\r\n     * The battery voltage of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    BatteryVoltage?: number;\r\n\r\n    /**\r\n     * The battery status of the sensor.\r\n     * Can be \"New\", \"Good\", \"Ok\", \"Low\", \"Critical\", or \"Invalid\".\r\n     * @type {\"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\" | undefined}\r\n     */\r\n    BatteryStatus?: \"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\";\r\n\r\n    /**\r\n     * The battery status bit of the sensor.\r\n     */\r\n    BatteryStatusBit?: number;\r\n\r\n    /**\r\n     * Indicates whether the sensor detects motion.\r\n     * @type {boolean | undefined}\r\n     */\r\n    Motion?: boolean;\r\n}\r\n","import { SpeedSensorState } from \"./speedSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Speed sensor during scanning.\r\n * Extends the SpeedSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class SpeedScanState extends SpeedSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value for the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#523_tab\r\n * Spec sheet: https://www.thisisant.com/resources/bicycle-speed-and-cadence/\r\n */\r\n\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\nimport { updateState } from \"./speedUtils.js\";\r\nimport { SpeedSensorState } from \"./speedSensorState.js\";\r\n\r\n/**\r\n * Represents a Bicycle Speed sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to speed measurement.\r\n *\r\n * @category Sensors\r\n */\r\nexport class SpeedSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Bicycle Speed sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 0x7b;\r\n\r\n    /**\r\n     * The wheel circumference in meters, used to calculate speed.\r\n     * @type {number}\r\n     * @default 2.199\r\n     */\r\n    wheelCircumference: number = 2.199; // default 70cm wheel\r\n\r\n    /**\r\n     * Sets the wheel circumference for speed calculation.\r\n     *\r\n     * @public\r\n     * @param {number} wheelCircumference - The wheel circumference in meters.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new SpeedSensor();\r\n     * sensor.setWheelCircumference(2.105); // Sets the wheel circumference to 2.105 meters\r\n     */\r\n    public setWheelCircumference(wheelCircumference: number) {\r\n        this.wheelCircumference = wheelCircumference;\r\n    }\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new SpeedSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, SpeedSensor.deviceType, 0, 255, 8118);\r\n        this.state = new SpeedSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * The current state of the Bicycle Speed sensor.\r\n     * @private\r\n     * @type {SpeedSensorState}\r\n     */\r\n    private state!: SpeedSensorState;\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView) {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n}\r\n","import { AntPlusScanner } from \"../antPlusScanner.js\";\r\nimport { updateState } from \"./speedUtils.js\";\r\nimport { SpeedScanState } from \"./speedScanState.js\";\r\nimport { SpeedSensor } from \"./speedSensor.js\";\r\n\r\n/**\r\n * Represents a scanner for Speed sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple Speed sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class SpeedScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Speed sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Speed sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return SpeedSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * The wheel circumference in meters, used to calculate speed.\r\n     * @type {number}\r\n     * @default 2.199\r\n     */\r\n    wheelCircumference: number = 2.199; // default 70cm wheel\r\n\r\n    /**\r\n     * Sets the wheel circumference for speed calculation.\r\n     *\r\n     * @public\r\n     * @param {number} wheelCircumference - The wheel circumference in meters.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const scanner = new SpeedScanner();\r\n     * scanner.setWheelCircumference(2.105); // Sets the wheel circumference to 2.105 meters\r\n     */\r\n    public setWheelCircumference(wheelCircumference: number): void {\r\n        this.wheelCircumference = wheelCircumference;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Speed sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: SpeedScanState }}\r\n     */\r\n    private states: { [id: number]: SpeedScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new SpeedScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { CadenceScanner } from \"./cadenceScanner.js\";\r\nimport { CadenceScanState } from \"./cadenceScanState.js\";\r\nimport { CadenceSensor } from \"./cadenceSensor.js\";\r\nimport { CadenceSensorState } from \"./cadenceSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\nconst TOGGLE_MASK = 0x80;\r\n\r\n/**\r\n * Updates the state of a Cadence sensor or scanner based on incoming data.\r\n * Decodes the data buffer and updates the sensor state accordingly, including\r\n * cumulative values such as operating time, manufacturer details, battery status,\r\n * and calculated cadence.\r\n *\r\n * @param {CadenceSensor | CadenceScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {CadenceSensorState | CadenceScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n */\r\nexport function updateState(sensor: CadenceSensor | CadenceScanner, state: CadenceSensorState | CadenceScanState, data: DataView): void {\r\n    const pageNum = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n\r\n    switch (\r\n        pageNum & ~TOGGLE_MASK // Check the new pages and remove the toggle bit\r\n    ) {\r\n        case 1:\r\n            // Decode the cumulative operating time\r\n            state.OperatingTime = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            state.OperatingTime |= data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2) << 8;\r\n            state.OperatingTime |= data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3) << 16;\r\n            state.OperatingTime *= 2;\r\n            break;\r\n        case 2:\r\n            // Decode the Manufacturer ID\r\n            state.ManId = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            // Decode the 4-byte serial number\r\n            state.SerialNumber = state.DeviceId;\r\n            state.SerialNumber |= data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 2, true) << 16;\r\n            state.SerialNumber >>>= 0;\r\n            break;\r\n        case 3:\r\n            // Decode HW version, SW version, and model number\r\n            state.HwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            state.SwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            state.ModelNum = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            break;\r\n        case 4: {\r\n            const batteryFrac = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const batteryStatus = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            state.BatteryVoltage = (batteryStatus & 0x0f) + batteryFrac / 256;\r\n            const batteryFlags = (batteryStatus & 0x70) >>> 4;\r\n            state.BatteryStatusBit = batteryFlags;\r\n            switch (batteryFlags) {\r\n                case 1:\r\n                    state.BatteryStatus = \"New\";\r\n                    break;\r\n                case 2:\r\n                    state.BatteryStatus = \"Good\";\r\n                    break;\r\n                case 3:\r\n                    state.BatteryStatus = \"Ok\";\r\n                    break;\r\n                case 4:\r\n                    state.BatteryStatus = \"Low\";\r\n                    break;\r\n                case 5:\r\n                    state.BatteryStatus = \"Critical\";\r\n                    break;\r\n                default:\r\n                    state.BatteryVoltage = undefined;\r\n                    state.BatteryStatus = \"Invalid\";\r\n                    break;\r\n            }\r\n            break;\r\n        }\r\n        case 5:\r\n            state.Motion = (data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1) & 0x01) === 0x01;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Get old state for calculating cumulative values\r\n    const oldCadenceTime = state.CadenceEventTime ?? 0;\r\n    const oldCadenceCount = state.CumulativeCadenceRevolutionCount ?? 0;\r\n\r\n    let cadenceTime = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n    let cadenceCount = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n\r\n    if (cadenceTime !== oldCadenceTime) {\r\n        state.CadenceEventTime = cadenceTime;\r\n        state.CumulativeCadenceRevolutionCount = cadenceCount;\r\n\r\n        if (oldCadenceTime > cadenceTime) {\r\n            // Handle rollover\r\n            cadenceTime += 1024 * 64;\r\n        }\r\n\r\n        if (oldCadenceCount > cadenceCount) {\r\n            // Handle rollover\r\n            cadenceCount += 1024 * 64;\r\n        }\r\n\r\n        const cadence = (60 * (cadenceCount - oldCadenceCount) * 1024) / (cadenceTime - oldCadenceTime);\r\n        if (!isNaN(cadence)) {\r\n            state.CalculatedCadence = cadence;\r\n            sensor.emit(\"cadenceData\", state);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Represents the state of a Cadence Sensor.\r\n * This class holds the data fields associated with the state of a cadence sensor,\r\n * including event times, revolution counts, and device information.\r\n */\r\nexport class CadenceSensorState {\r\n    /**\r\n     * Creates an instance of the CadenceSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     *\r\n     * @example\r\n     * const sensorState = new CadenceSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The time of the last cadence event, in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    CadenceEventTime: number | undefined;\r\n\r\n    /**\r\n     * The cumulative number of cadence revolutions counted by the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    CumulativeCadenceRevolutionCount: number | undefined;\r\n\r\n    /**\r\n     * The calculated cadence in revolutions per minute (RPM).\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedCadence: number | undefined;\r\n\r\n    /**\r\n     * The cumulative operating time of the sensor in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    OperatingTime?: number;\r\n\r\n    /**\r\n     * The manufacturer ID of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ManId?: number;\r\n\r\n    /**\r\n     * The serial number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SerialNumber?: number;\r\n\r\n    /**\r\n     * The hardware version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    HwVersion?: number;\r\n\r\n    /**\r\n     * The software version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SwVersion?: number;\r\n\r\n    /**\r\n     * The model number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ModelNum?: number;\r\n\r\n    /**\r\n     * The battery voltage of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    BatteryVoltage?: number;\r\n\r\n    /**\r\n     * The battery status of the sensor.\r\n     * Can be one of the following: \"New\", \"Good\", \"Ok\", \"Low\", \"Critical\", \"Invalid\".\r\n     * @type {\"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\" | undefined}\r\n     */\r\n    BatteryStatus?: \"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\";\r\n\r\n    /**\r\n     * The battery status bit of the sensor.\r\n     */\r\n    BatteryStatusBit?: number;\r\n\r\n    /**\r\n     * Indicates whether the sensor is in motion.\r\n     * @type {boolean | undefined}\r\n     */\r\n    Motion?: boolean;\r\n}\r\n","import { CadenceSensorState } from \"./cadenceSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Cadence Sensor during scanning.\r\n * Extends the CadenceSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class CadenceScanState extends CadenceSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * Indicates the strength of the received signal from the cadence sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value for the sensor.\r\n     * Represents the minimum signal strength required for a reliable connection.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#523_tab\r\n * Spec sheet: https://www.thisisant.com/resources/bicycle-speed-and-cadence/\r\n */\r\n\r\nimport { updateState } from \"./cadenceUtils.js\";\r\nimport { CadenceSensorState } from \"./cadenceSensorState.js\";\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\n\r\n/**\r\n * Represents a Bicycle Cadence sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to cadence measurement.\r\n *\r\n * @category Sensors\r\n */\r\nexport class CadenceSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Bicycle Cadence sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 0x7a;\r\n\r\n    /**\r\n     * The wheel circumference in meters, used to calculate speed.\r\n     * @type {number}\r\n     * @default 2.199\r\n     */\r\n    wheelCircumference: number = 2.199; // default 70cm wheel\r\n\r\n    /**\r\n     * The current state of the Bicycle Cadence sensor.\r\n     * @private\r\n     * @type {CadenceSensorState}\r\n     */\r\n    private state!: CadenceSensorState;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new CadenceSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, CadenceSensor.deviceType, 0, 255, 8102);\r\n        this.state = new CadenceSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * Sets the wheel circumference for speed calculation.\r\n     *\r\n     * @public\r\n     * @param {number} wheelCircumference - The wheel circumference in meters.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new CadenceSensor();\r\n     * sensor.setWheelCircumference(2.105); // Sets the wheel circumference to 2.105 meters\r\n     */\r\n    public setWheelCircumference(wheelCircumference: number): void {\r\n        this.wheelCircumference = wheelCircumference;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n}\r\n","import { updateState } from \"./cadenceUtils.js\";\r\nimport { CadenceScanState } from \"./cadenceScanState.js\";\r\nimport { CadenceSensor } from \"./cadenceSensor.js\";\r\nimport { AntPlusScanner } from \"../antPlusScanner.js\";\r\n\r\n/**\r\n * Represents a scanner for Cadence sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple cadence sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class CadenceScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Cadence sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Cadence sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return CadenceSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * The wheel circumference used for cadence calculations, in meters.\r\n     * Defaults to 2.199 meters (70 cm wheel).\r\n     * @type {number}\r\n     */\r\n    wheelCircumference: number = 2.199;\r\n\r\n    /**\r\n     * Sets the wheel circumference for cadence calculations.\r\n     *\r\n     * @public\r\n     * @param {number} wheelCircumference - The wheel circumference in meters.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.setWheelCircumference(2.105); // Sets the wheel circumference to 2.105 meters\r\n     */\r\n    public setWheelCircumference(wheelCircumference: number): void {\r\n        this.wheelCircumference = wheelCircumference;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Cadence sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: CadenceScanState }}\r\n     */\r\n    private states: { [id: number]: CadenceScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new CadenceScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { BicyclePowerScanner } from \"./bicyclePowerScanner.js\";\r\nimport { BicyclePowerScanState } from \"./bicyclePowerScanState.js\";\r\nimport { BicyclePowerSensor } from \"./bicyclePowerSensor.js\";\r\nimport { BicyclePowerSensorState } from \"./bicyclePowerSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\n/**\r\n * Updates the state of a Bicycle Power sensor or scanner based on incoming data.\r\n * Processes various types of data pages to update the sensor state, including calibration data,\r\n * pedal power, cadence, and torque calculations.\r\n *\r\n * @param {BicyclePowerSensor | BicyclePowerScanner} sensor - The sensor or scanner to update.\r\n * @param {BicyclePowerSensorState | BicyclePowerScanState} state - The state object representing the current state of the sensor.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n */\r\nexport function updateState(sensor: BicyclePowerSensor | BicyclePowerScanner, state: BicyclePowerSensorState | BicyclePowerScanState, data: DataView): void {\r\n    const page = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n\r\n    switch (page) {\r\n        case 0x01: {\r\n            const calId = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            if (calId === 0x10) {\r\n                const calParam = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n                if (calParam === 0x01) {\r\n                    state.offset = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true); // true for little-endian\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case 0x10: {\r\n            const pedalPower = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            if (pedalPower !== 0xff) {\r\n                if (pedalPower & 0x80) {\r\n                    state.PedalPower = pedalPower & 0x7f;\r\n                    state.RightPedalPower = state.PedalPower;\r\n                    state.LeftPedalPower = 100 - state.RightPedalPower;\r\n                } else {\r\n                    state.PedalPower = pedalPower & 0x7f;\r\n                    state.RightPedalPower = undefined;\r\n                    state.LeftPedalPower = undefined;\r\n                }\r\n            } else {\r\n                state.PedalPower = undefined;\r\n                state.RightPedalPower = undefined;\r\n                state.LeftPedalPower = undefined;\r\n            }\r\n\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            state.Cadence = cadence !== 0xff ? cadence : undefined;\r\n\r\n            state.AccumulatedPower = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            state.Power = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n            break;\r\n        }\r\n        case 0x20: {\r\n            const oldEventCount = state.EventCount ?? 0;\r\n            const oldTimeStamp = state.TimeStamp ?? 0;\r\n            const oldTorqueTicksStamp = state.TorqueTicksStamp ?? 0;\r\n\r\n            let eventCount = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            const slope = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 3, true);\r\n            let timeStamp = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true);\r\n            let torqueTicksStamp = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 7, true);\r\n\r\n            if (timeStamp !== oldTimeStamp && eventCount !== oldEventCount) {\r\n                state.EventCount = eventCount;\r\n                if (oldEventCount > eventCount) {\r\n                    // Hit rollover value\r\n                    eventCount += 255;\r\n                }\r\n\r\n                state.TimeStamp = timeStamp;\r\n                if (oldTimeStamp > timeStamp) {\r\n                    // Hit rollover value\r\n                    timeStamp += 65400;\r\n                }\r\n\r\n                state.Slope = slope;\r\n                state.TorqueTicksStamp = torqueTicksStamp;\r\n                if (oldTorqueTicksStamp > torqueTicksStamp) {\r\n                    // Hit rollover value\r\n                    torqueTicksStamp += 65535;\r\n                }\r\n\r\n                const elapsedTime = (timeStamp - oldTimeStamp) * 0.0005;\r\n                const torqueTicks = torqueTicksStamp - oldTorqueTicksStamp;\r\n\r\n                const cadencePeriod = elapsedTime / (eventCount - oldEventCount); // seconds\r\n                const cadence = Math.round(60 / cadencePeriod); // RPM\r\n                state.CalculatedCadence = cadence;\r\n\r\n                const torqueFrequency = 1 / (elapsedTime / torqueTicks) - state.offset; // Hz\r\n                const torque = torqueFrequency / (slope / 10); // Nm\r\n                state.CalculatedTorque = torque;\r\n\r\n                state.CalculatedPower = (torque * cadence * Math.PI) / 30; // Watts\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n            return;\r\n    }\r\n    sensor.emit(\"powerData\", state);\r\n}\r\n","/**\r\n * Represents the state of a Bicycle Power sensor.\r\n * Stores various metrics and calculated values related to bicycle power, such as pedal power, cadence, torque, and power.\r\n */\r\nexport class BicyclePowerSensorState {\r\n    /**\r\n     * Creates an instance of BicyclePowerSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The total pedal power percentage.\r\n     * Represents the percentage of power produced by the pedal strokes.\r\n     * @type {number | undefined}\r\n     */\r\n    PedalPower?: number;\r\n\r\n    /**\r\n     * The power percentage from the right pedal.\r\n     * If available, represents the contribution of the right pedal to the total power.\r\n     * @type {number | undefined}\r\n     */\r\n    RightPedalPower?: number;\r\n\r\n    /**\r\n     * The power percentage from the left pedal.\r\n     * If available, represents the contribution of the left pedal to the total power.\r\n     * @type {number | undefined}\r\n     */\r\n    LeftPedalPower?: number;\r\n\r\n    /**\r\n     * The cadence value in revolutions per minute (RPM).\r\n     * Represents the number of pedal revolutions per minute.\r\n     * @type {number | undefined}\r\n     */\r\n    Cadence?: number;\r\n\r\n    /**\r\n     * The accumulated power in watts.\r\n     * Represents the total power output accumulated over time.\r\n     * @type {number | undefined}\r\n     */\r\n    AccumulatedPower?: number;\r\n\r\n    /**\r\n     * The current power output in watts.\r\n     * Represents the instantaneous power output of the cyclist.\r\n     * @type {number | undefined}\r\n     */\r\n    Power?: number;\r\n\r\n    /**\r\n     * The offset value used for torque calculations.\r\n     * @type {number}\r\n     * @default 0\r\n     */\r\n    offset: number = 0;\r\n\r\n    /**\r\n     * The event count value.\r\n     * Represents the number of events recorded by the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    EventCount?: number;\r\n\r\n    /**\r\n     * The timestamp of the last recorded event.\r\n     * Represents the time at which the last event was recorded.\r\n     * @type {number | undefined}\r\n     */\r\n    TimeStamp?: number;\r\n\r\n    /**\r\n     * The slope value used for torque calculations.\r\n     * Represents the slope or gradient used in the torque computation.\r\n     * @type {number | undefined}\r\n     */\r\n    Slope?: number;\r\n\r\n    /**\r\n     * The timestamp for the last torque tick.\r\n     * Represents the time at which the last torque measurement was recorded.\r\n     * @type {number | undefined}\r\n     */\r\n    TorqueTicksStamp?: number;\r\n\r\n    /**\r\n     * The calculated cadence in RPM.\r\n     * Represents the calculated cadence based on sensor data.\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedCadence?: number;\r\n\r\n    /**\r\n     * The calculated torque in Newton meters (Nm).\r\n     * Represents the torque calculated from sensor data.\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedTorque?: number;\r\n\r\n    /**\r\n     * The calculated power in watts.\r\n     * Represents the power calculated from torque and cadence data.\r\n     * @type {number | undefined}\r\n     */\r\n    CalculatedPower?: number;\r\n}\r\n","import { BicyclePowerSensorState } from \"./bicyclePowerSensorState.js\";\r\n\r\n/**\r\n * Represents the scan state of a Bicycle Power sensor.\r\n * Extends the BicyclePowerSensorState to include additional data related to signal quality during a scan.\r\n */\r\nexport class BicyclePowerScanState extends BicyclePowerSensorState {\r\n    /**\r\n     * Received Signal Strength Indicator (RSSI).\r\n     * Represents the strength of the received signal from the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The threshold value for the RSSI.\r\n     * Represents the minimum acceptable signal strength for communication.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#521_tab\r\n * Spec sheet: https://www.thisisant.com/resources/bicycle-power/\r\n */\r\n\r\nimport { updateState } from \"./bicyclePowerUtils.js\";\r\nimport { BicyclePowerSensorState } from \"./bicyclePowerSensorState.js\";\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\n\r\n/**\r\n * Represents a Bicycle Power sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to bicycle power measurement.\r\n *\r\n * @category Sensors\r\n */\r\nexport class BicyclePowerSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Bicycle Power sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 0x0b;\r\n\r\n    /**\r\n     * The current state of the Bicycle Power sensor.\r\n     * @private\r\n     * @type {BicyclePowerSensorState}\r\n     */\r\n    private state!: BicyclePowerSensorState;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new BicyclePowerSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, BicyclePowerSensor.deviceType, 0, 255, 8182);\r\n        this.state = new BicyclePowerSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n}\r\n","import { updateState } from \"./bicyclePowerUtils.js\";\r\nimport { BicyclePowerScanState } from \"./bicyclePowerScanState.js\";\r\nimport { BicyclePowerSensor } from \"./bicyclePowerSensor.js\";\r\nimport { AntPlusScanner } from \"../antPlusScanner.js\";\r\n\r\n/**\r\n * Represents a scanner for Bicycle Power sensors.\r\n * Extends the AntPlusScanner class to handle scanning for multiple Bicycle Power sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class BicyclePowerScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type for Bicycle Power sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type identifier for Bicycle Power sensors.\r\n     */\r\n    protected deviceType() {\r\n        return BicyclePowerSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * A collection of states for each detected Bicycle Power sensor, keyed by device ID.\r\n     * @private\r\n     * @type {{ [id: number]: BicyclePowerScanState }}\r\n     */\r\n    private states: { [id: number]: BicyclePowerScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a Bicycle Power sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     */\r\n    protected createStateIfNew(deviceId: number) {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new BicyclePowerScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and threshold for a specific Bicycle Power sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator value.\r\n     * @param {number} threshold - The threshold value for the RSSI.\r\n     * @returns {void}\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number) {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a specific Bicycle Power sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView) {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { Messages } from \"../../utils/messages.js\";\r\nimport { FitnessEquipmentSensorState } from \"./fitnessEquipmentSensorState.js\";\r\nimport { FitnessEquipmentScanState } from \"./fitnessEquipmentScanState.js\";\r\nimport { FitnessEquipmentSensor } from \"./fitnessEquipmentSensor.js\";\r\nimport { FitnessEquipmentScanner } from \"./fitnessEquipmentScanner.js\";\r\n\r\n/**\r\n * Resets the state of the fitness equipment sensor by deleting all relevant properties.\r\n *\r\n * @param {FitnessEquipmentSensorState | FitnessEquipmentScanState} state - The state object of the fitness equipment sensor to reset.\r\n * @returns {void}\r\n */\r\nfunction resetState(state: FitnessEquipmentSensorState | FitnessEquipmentScanState): void {\r\n    delete state.ElapsedTime;\r\n    delete state.Distance;\r\n    delete state.RealSpeed;\r\n    delete state.VirtualSpeed;\r\n    delete state.HeartRate;\r\n    delete state.HeartRateSource;\r\n    delete state.CycleLength;\r\n    delete state.Incline;\r\n    delete state.Resistance;\r\n    delete state.METs;\r\n    delete state.CaloricBurnRate;\r\n    delete state.Calories;\r\n    delete state._EventCount0x19;\r\n    delete state._EventCount0x1A;\r\n    delete state.Cadence;\r\n    delete state.AccumulatedPower;\r\n    delete state.InstantaneousPower;\r\n    delete state.AveragePower;\r\n    delete state.TrainerStatus;\r\n    delete state.TargetStatus;\r\n    delete state.AscendedDistance;\r\n    delete state.DescendedDistance;\r\n    delete state.Strides;\r\n    delete state.Strokes;\r\n    delete state.WheelTicks;\r\n    delete state.WheelPeriod;\r\n    delete state.Torque;\r\n}\r\n\r\n/**\r\n * Updates the state of the fitness equipment sensor or scanner based on the received data.\r\n *\r\n * @param {FitnessEquipmentSensor | FitnessEquipmentScanner} sensor - The sensor or scanner instance to update.\r\n * @param {FitnessEquipmentSensorState | FitnessEquipmentScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the fitness equipment.\r\n * @returns {void}\r\n *\r\n * @example\r\n * updateState(sensor, state, data);\r\n */\r\nexport function updateState(sensor: FitnessEquipmentSensor | FitnessEquipmentScanner, state: FitnessEquipmentSensorState | FitnessEquipmentScanState, data: DataView): void {\r\n    const page = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n    switch (page) {\r\n        case 0x01: {\r\n            const temperature = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            if (temperature !== 0xff) {\r\n                state.Temperature = -25 + temperature * 0.5;\r\n            }\r\n            const calBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            if (calBF & 0x40) {\r\n                state.ZeroOffset = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            }\r\n            if (calBF & 0x80) {\r\n                state.SpinDownTime = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n            }\r\n            break;\r\n        }\r\n        case 0x10: {\r\n            const equipmentTypeBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            switch (equipmentTypeBF & 0x1f) {\r\n                case 19:\r\n                    state.EquipmentType = \"Treadmill\";\r\n                    break;\r\n                case 20:\r\n                    state.EquipmentType = \"Elliptical\";\r\n                    break;\r\n                case 21:\r\n                    state.EquipmentType = \"Reserved\";\r\n                    break;\r\n                case 22:\r\n                    state.EquipmentType = \"Rower\";\r\n                    break;\r\n                case 23:\r\n                    state.EquipmentType = \"Climber\";\r\n                    break;\r\n                case 24:\r\n                    state.EquipmentType = \"NordicSkier\";\r\n                    break;\r\n                case 25:\r\n                    state.EquipmentType = \"Trainer/StationaryBike\";\r\n                    break;\r\n                default:\r\n                    state.EquipmentType = \"General\";\r\n                    break;\r\n            }\r\n            let elapsedTime = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            let distance = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const speed = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            const heartRate = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n            const capStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n            if (heartRate !== 0xff) {\r\n                switch (capStateBF & 0x03) {\r\n                    case 3: {\r\n                        state.HeartRate = heartRate;\r\n                        state.HeartRateSource = \"HandContact\";\r\n                        break;\r\n                    }\r\n                    case 2: {\r\n                        state.HeartRate = heartRate;\r\n                        state.HeartRateSource = \"EM\";\r\n                        break;\r\n                    }\r\n                    case 1: {\r\n                        state.HeartRate = heartRate;\r\n                        state.HeartRateSource = \"ANT+\";\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        delete state.HeartRate;\r\n                        delete state.HeartRateSource;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            elapsedTime /= 4;\r\n            const oldElapsedTime = (state.ElapsedTime || 0) % 64;\r\n            if (elapsedTime !== oldElapsedTime) {\r\n                if (oldElapsedTime > elapsedTime) {\r\n                    // Hit rollover value\r\n                    elapsedTime += 64;\r\n                }\r\n            }\r\n            state.ElapsedTime = (state.ElapsedTime || 0) + elapsedTime - oldElapsedTime;\r\n\r\n            if (capStateBF & 0x04) {\r\n                const oldDistance = (state.Distance || 0) % 256;\r\n                if (distance !== oldDistance) {\r\n                    if (oldDistance > distance) {\r\n                        // Hit rollover value\r\n                        distance += 256;\r\n                    }\r\n                }\r\n                state.Distance = (state.Distance || 0) + distance - oldDistance;\r\n            } else {\r\n                delete state.Distance;\r\n            }\r\n            if (capStateBF & 0x08) {\r\n                state.VirtualSpeed = speed / 1000;\r\n                delete state.RealSpeed;\r\n            } else {\r\n                delete state.VirtualSpeed;\r\n                state.RealSpeed = speed / 1000;\r\n            }\r\n            switch ((capStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (capStateBF & 0x80) {\r\n                // lap\r\n            }\r\n            break;\r\n        }\r\n        case 0x11: {\r\n            const cycleLen = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const incline = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            const resistance = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n            const capStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n            if (cycleLen !== 0xff) {\r\n                state.CycleLength = cycleLen / 100;\r\n            }\r\n            if (incline >= -10000 && incline <= 10000) {\r\n                state.Incline = incline / 100;\r\n            }\r\n            if (resistance !== 0xff) {\r\n                state.Resistance = resistance;\r\n            }\r\n            switch ((capStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (capStateBF & 0x80) {\r\n                // lap\r\n            }\r\n            break;\r\n        }\r\n        case 0x12: {\r\n            const mets = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 2, true);\r\n            const caloricbr = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            const calories = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n            const capStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n            if (mets !== 0xffff) {\r\n                state.METs = mets / 100;\r\n            }\r\n            if (caloricbr !== 0xffff) {\r\n                state.CaloricBurnRate = caloricbr / 10;\r\n            }\r\n            if (capStateBF & 0x01) {\r\n                state.Calories = calories;\r\n            }\r\n            switch ((capStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (capStateBF & 0x80) {\r\n                // lap\r\n            }\r\n            break;\r\n        }\r\n        case 0x13: {\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4);\r\n            let negDistance = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 5);\r\n            let posDistance = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (cadence !== 0xff) {\r\n                state.Cadence = cadence;\r\n            }\r\n\r\n            if (flagStateBF & 0x02) {\r\n                const oldNegDistance = (state.DescendedDistance || 0) % 256;\r\n                if (negDistance !== oldNegDistance) {\r\n                    if (oldNegDistance > negDistance) {\r\n                        negDistance += 256;\r\n                    }\r\n                }\r\n                state.DescendedDistance = (state.DescendedDistance || 0) + negDistance - oldNegDistance;\r\n            }\r\n\r\n            if (flagStateBF & 0x01) {\r\n                const oldPosDistance = (state.AscendedDistance || 0) % 256;\r\n                if (posDistance !== oldPosDistance) {\r\n                    if (oldPosDistance > posDistance) {\r\n                        posDistance += 256;\r\n                    }\r\n                }\r\n                state.AscendedDistance = (state.AscendedDistance || 0) + posDistance - oldPosDistance;\r\n            }\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x14: {\r\n            let posDistance = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            let strides = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4);\r\n            const power = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true);\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (cadence !== 0xff) {\r\n                state.Cadence = cadence;\r\n            }\r\n\r\n            if (power !== 0xffff) {\r\n                state.InstantaneousPower = power;\r\n            }\r\n\r\n            if (flagStateBF & 0x02) {\r\n                const oldPosDistance = (state.AscendedDistance || 0) % 256;\r\n                if (posDistance !== oldPosDistance) {\r\n                    if (oldPosDistance > posDistance) {\r\n                        posDistance += 256;\r\n                    }\r\n                }\r\n                state.AscendedDistance = (state.AscendedDistance || 0) + posDistance - oldPosDistance;\r\n            }\r\n\r\n            if (flagStateBF & 0x01) {\r\n                const oldStrides = (state.Strides || 0) % 256;\r\n                if (strides !== oldStrides) {\r\n                    if (oldStrides > strides) {\r\n                        strides += 256;\r\n                    }\r\n                }\r\n                state.Strides = (state.Strides || 0) + strides - oldStrides;\r\n            }\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x16: {\r\n            let strokes = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4);\r\n            const power = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true);\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (cadence !== 0xff) {\r\n                state.Cadence = cadence;\r\n            }\r\n\r\n            if (power !== 0xffff) {\r\n                state.InstantaneousPower = power;\r\n            }\r\n\r\n            if (flagStateBF & 0x01) {\r\n                const oldStrokes = (state.Strokes || 0) % 256;\r\n                if (strokes !== oldStrokes) {\r\n                    if (oldStrokes > strokes) {\r\n                        strokes += 256;\r\n                    }\r\n                }\r\n                state.Strokes = (state.Strokes || 0) + strokes - oldStrokes;\r\n            }\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x17: {\r\n            let strides = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4);\r\n            const power = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true);\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (cadence !== 0xff) {\r\n                state.Cadence = cadence;\r\n            }\r\n\r\n            if (power !== 0xffff) {\r\n                state.InstantaneousPower = power;\r\n            }\r\n\r\n            if (flagStateBF & 0x01) {\r\n                const oldStrides = (state.Strides || 0) % 256;\r\n                if (strides !== oldStrides) {\r\n                    if (oldStrides > strides) {\r\n                        strides += 256;\r\n                    }\r\n                }\r\n                state.Strides = (state.Strides || 0) + strides - oldStrides;\r\n            }\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x18: {\r\n            let strides = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 4);\r\n            const power = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true);\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (cadence !== 0xff) {\r\n                state.Cadence = cadence;\r\n            }\r\n\r\n            if (power !== 0xffff) {\r\n                state.InstantaneousPower = power;\r\n            }\r\n\r\n            if (flagStateBF & 0x01) {\r\n                const oldStrides = (state.Strides || 0) % 256;\r\n                if (strides !== oldStrides) {\r\n                    if (oldStrides > strides) {\r\n                        strides += 256;\r\n                    }\r\n                }\r\n                state.Strides = (state.Strides || 0) + strides - oldStrides;\r\n            }\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x19: {\r\n            const oldEventCount = state._EventCount0x19 || 0;\r\n\r\n            let eventCount = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            const cadence = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            let accPower = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 3, true);\r\n            const power = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true) & 0xfff;\r\n            const trainerStatus = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6) >> 4;\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (eventCount !== oldEventCount) {\r\n                state._EventCount0x19 = eventCount;\r\n                if (oldEventCount > eventCount) {\r\n                    //Hit rollover value\r\n                    eventCount += 255;\r\n                }\r\n            }\r\n\r\n            if (cadence !== 0xff) {\r\n                state.Cadence = cadence;\r\n            }\r\n\r\n            if (power !== 0xfff) {\r\n                state.InstantaneousPower = power;\r\n\r\n                const oldAccPower = (state.AccumulatedPower || 0) % 65536;\r\n                if (accPower !== oldAccPower) {\r\n                    if (oldAccPower > accPower) {\r\n                        accPower += 65536;\r\n                    }\r\n                }\r\n                state.AccumulatedPower = (state.AccumulatedPower || 0) + accPower - oldAccPower;\r\n\r\n                state.AveragePower = (accPower - oldAccPower) / (eventCount - oldEventCount);\r\n            }\r\n\r\n            state.TrainerStatus = trainerStatus;\r\n\r\n            switch (flagStateBF & 0x03) {\r\n                case 0:\r\n                    state.TargetStatus = \"OnTarget\";\r\n                    break;\r\n                case 1:\r\n                    state.TargetStatus = \"LowSpeed\";\r\n                    break;\r\n                case 2:\r\n                    state.TargetStatus = \"HighSpeed\";\r\n                    break;\r\n                default:\r\n                    delete state.TargetStatus;\r\n                    break;\r\n            }\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x1a: {\r\n            const oldEventCount = state._EventCount0x1A || 0;\r\n\r\n            let eventCount = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            let wheelTicks = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            let accWheelPeriod = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 3, true);\r\n            let accTorque = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true);\r\n            const flagStateBF = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (eventCount !== oldEventCount) {\r\n                state._EventCount0x1A = eventCount;\r\n                if (oldEventCount > eventCount) {\r\n                    //Hit rollover value\r\n                    eventCount += 255;\r\n                }\r\n            }\r\n\r\n            const oldWheelTicks = (state.WheelTicks || 0) % 256;\r\n            if (wheelTicks !== oldWheelTicks) {\r\n                if (oldWheelTicks > wheelTicks) {\r\n                    wheelTicks += 65536;\r\n                }\r\n            }\r\n            state.WheelTicks = (state.WheelTicks || 0) + wheelTicks - oldWheelTicks;\r\n\r\n            const oldWheelPeriod = (state.WheelPeriod || 0) % 256;\r\n            if (accWheelPeriod !== oldWheelPeriod) {\r\n                if (oldWheelPeriod > accWheelPeriod) {\r\n                    accWheelPeriod += 65536;\r\n                }\r\n            }\r\n            state.WheelPeriod = (state.WheelPeriod || 0) + accWheelPeriod - oldWheelPeriod;\r\n\r\n            const oldTorque = (state.Torque || 0) % 256;\r\n            if (accTorque !== oldTorque) {\r\n                if (oldTorque > accTorque) {\r\n                    accTorque += 65536;\r\n                }\r\n            }\r\n            state.Torque = (state.Torque || 0) + accTorque - oldTorque;\r\n\r\n            switch ((flagStateBF & 0x70) >> 4) {\r\n                case 1:\r\n                    state.State = \"OFF\";\r\n                    break;\r\n                case 2:\r\n                    state.State = \"READY\";\r\n                    resetState(state);\r\n                    break;\r\n                case 3:\r\n                    state.State = \"IN_USE\";\r\n                    break;\r\n                case 4:\r\n                    state.State = \"FINISHED\";\r\n                    break;\r\n                default:\r\n                    delete state.State;\r\n                    break;\r\n            }\r\n            if (flagStateBF & 0x80) {\r\n                // lap\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x50: {\r\n            state.HwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            state.ManId = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            state.ModelNum = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n            break;\r\n        }\r\n        case 0x51: {\r\n            const swRevSup = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const swRevMain = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const serial = data.getUint32(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n\r\n            state.SwVersion = swRevMain;\r\n\r\n            if (swRevSup !== 0xff) {\r\n                state.SwVersion += swRevSup / 1000;\r\n            }\r\n\r\n            if (serial !== 0xffffffff) {\r\n                state.SerialNumber = serial;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x56: {\r\n            const idx = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            const tot = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const chState = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const devId = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            const trType = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 6);\r\n            const devType = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 7);\r\n\r\n            if (idx === 0) {\r\n                state.PairedDevices = [];\r\n            }\r\n\r\n            if (tot > 0) {\r\n                state.PairedDevices.push({\r\n                    id: devId,\r\n                    type: devType,\r\n                    paired: chState & 0x80 ? true : false,\r\n                });\r\n            }\r\n\r\n            break;\r\n        }\r\n        default:\r\n            return;\r\n    }\r\n    sensor.emit(\"fitnessData\", state);\r\n}\r\n","import { PairedDevice } from \"../../types/pairedDevice.js\";\r\n\r\n/**\r\n * Represents the state of a Fitness Equipment sensor.\r\n * This class holds the data fields associated with the state of a fitness equipment sensor,\r\n * including metrics such as heart rate, speed, distance, power, and more.\r\n */\r\nexport class FitnessEquipmentSensorState {\r\n    /**\r\n     * Creates an instance of the FitnessEquipmentSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @example\r\n     * const sensorState = new FitnessEquipmentSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The event count for page 0x19.\r\n     * @type {number | undefined}\r\n     */\r\n    _EventCount0x19?: number;\r\n\r\n    /**\r\n     * The event count for page 0x1A.\r\n     * @type {number | undefined}\r\n     */\r\n    _EventCount0x1A?: number;\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The temperature measured by the sensor, in degrees Celsius.\r\n     * @type {number | undefined}\r\n     */\r\n    Temperature?: number;\r\n\r\n    /**\r\n     * The zero offset calibration value for the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ZeroOffset?: number;\r\n\r\n    /**\r\n     * The spin-down time for the sensor, in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    SpinDownTime?: number;\r\n\r\n    /**\r\n     * The type of fitness equipment.\r\n     * Can be \"Treadmill\", \"Elliptical\", \"Reserved\", \"Rower\", \"Climber\", \"NordicSkier\", \"Trainer/StationaryBike\", or \"General\".\r\n     * @type {\"Treadmill\" | \"Elliptical\" | \"Reserved\" | \"Rower\" | \"Climber\" | \"NordicSkier\" | \"Trainer/StationaryBike\" | \"General\" | undefined}\r\n     */\r\n    EquipmentType?: \"Treadmill\" | \"Elliptical\" | \"Reserved\" | \"Rower\" | \"Climber\" | \"NordicSkier\" | \"Trainer/StationaryBike\" | \"General\";\r\n\r\n    /**\r\n     * The total elapsed time, in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    ElapsedTime?: number;\r\n\r\n    /**\r\n     * The total distance traveled, in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    Distance?: number;\r\n\r\n    /**\r\n     * The real speed of the equipment, in meters per second.\r\n     * @type {number | undefined}\r\n     */\r\n    RealSpeed?: number;\r\n\r\n    /**\r\n     * The virtual speed of the equipment, in meters per second.\r\n     * @type {number | undefined}\r\n     */\r\n    VirtualSpeed?: number;\r\n\r\n    /**\r\n     * The current heart rate, in beats per minute (BPM).\r\n     * @type {number | undefined}\r\n     */\r\n    HeartRate?: number;\r\n\r\n    /**\r\n     * The source of the heart rate data.\r\n     * Can be \"HandContact\", \"EM\", or \"ANT+\".\r\n     * @type {\"HandContact\" | \"EM\" | \"ANT+\" | undefined}\r\n     */\r\n    HeartRateSource?: \"HandContact\" | \"EM\" | \"ANT+\";\r\n\r\n    /**\r\n     * The state of the equipment.\r\n     * Can be \"OFF\", \"READY\", \"IN_USE\", or \"FINISHED\".\r\n     * @type {\"OFF\" | \"READY\" | \"IN_USE\" | \"FINISHED\" | undefined}\r\n     */\r\n    State?: \"OFF\" | \"READY\" | \"IN_USE\" | \"FINISHED\";\r\n\r\n    /**\r\n     * The cycle length of the equipment, in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    CycleLength?: number;\r\n\r\n    /**\r\n     * The incline of the equipment, in percentage.\r\n     * @type {number | undefined}\r\n     */\r\n    Incline?: number;\r\n\r\n    /**\r\n     * The resistance level of the equipment.\r\n     * @type {number | undefined}\r\n     */\r\n    Resistance?: number;\r\n\r\n    /**\r\n     * The metabolic equivalent (MET) value.\r\n     * @type {number | undefined}\r\n     */\r\n    METs?: number;\r\n\r\n    /**\r\n     * The caloric burn rate, in kilocalories per hour.\r\n     * @type {number | undefined}\r\n     */\r\n    CaloricBurnRate?: number;\r\n\r\n    /**\r\n     * The total calories burned.\r\n     * @type {number | undefined}\r\n     */\r\n    Calories?: number;\r\n\r\n    /**\r\n     * The distance ascended, in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    AscendedDistance?: number;\r\n\r\n    /**\r\n     * The distance descended, in meters.\r\n     * @type {number | undefined}\r\n     */\r\n    DescendedDistance?: number;\r\n\r\n    /**\r\n     * The total number of strides taken.\r\n     * @type {number | undefined}\r\n     */\r\n    Strides?: number;\r\n\r\n    /**\r\n     * The total number of strokes taken.\r\n     * @type {number | undefined}\r\n     */\r\n    Strokes?: number;\r\n\r\n    /**\r\n     * The current cadence, in revolutions per minute (RPM).\r\n     * @type {number | undefined}\r\n     */\r\n    Cadence?: number;\r\n\r\n    /**\r\n     * The total accumulated power output, in watts.\r\n     * @type {number | undefined}\r\n     */\r\n    AccumulatedPower?: number;\r\n\r\n    /**\r\n     * The instantaneous power output, in watts.\r\n     * @type {number | undefined}\r\n     */\r\n    InstantaneousPower?: number;\r\n\r\n    /**\r\n     * The average power output, in watts.\r\n     * @type {number | undefined}\r\n     */\r\n    AveragePower?: number;\r\n\r\n    /**\r\n     * The trainer status, typically indicating the current mode or condition of the trainer.\r\n     * @type {number | undefined}\r\n     */\r\n    TrainerStatus?: number;\r\n\r\n    /**\r\n     * The target status of the equipment.\r\n     * Can be \"OnTarget\", \"LowSpeed\", or \"HighSpeed\".\r\n     * @type {\"OnTarget\" | \"LowSpeed\" | \"HighSpeed\" | undefined}\r\n     */\r\n    TargetStatus?: \"OnTarget\" | \"LowSpeed\" | \"HighSpeed\";\r\n\r\n    /**\r\n     * The total number of wheel ticks.\r\n     * @type {number | undefined}\r\n     */\r\n    WheelTicks?: number;\r\n\r\n    /**\r\n     * The wheel period, in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    WheelPeriod?: number;\r\n\r\n    /**\r\n     * The torque value, in newton-meters.\r\n     * @type {number | undefined}\r\n     */\r\n    Torque?: number;\r\n\r\n    /**\r\n     * The hardware version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    HwVersion?: number;\r\n\r\n    /**\r\n     * The manufacturer ID of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ManId?: number;\r\n\r\n    /**\r\n     * The model number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ModelNum?: number;\r\n\r\n    /**\r\n     * The software version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SwVersion?: number;\r\n\r\n    /**\r\n     * The serial number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SerialNumber?: number;\r\n\r\n    /**\r\n     * The list of paired devices associated with the sensor.\r\n     * @type {PairedDevice[]}\r\n     */\r\n    PairedDevices: PairedDevice[] = [];\r\n}\r\n","import { FitnessEquipmentSensorState } from \"./fitnessEquipmentSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Fitness Equipment sensor during scanning.\r\n * Extends the FitnessEquipmentSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class FitnessEquipmentScanState extends FitnessEquipmentSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * Indicates the strength of the received signal from the fitness equipment sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value for the sensor.\r\n     * Represents the minimum signal strength required for a reliable connection.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#521_tab\r\n * Spec sheet: https://www.thisisant.com/resources/bicycle-power/\r\n */\r\n\r\nimport { updateState } from \"./fitnessEquipmentUtils.js\";\r\nimport { FitnessEquipmentSensorState } from \"./fitnessEquipmentSensorState.js\";\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\nimport { SendCallback } from \"../../types/sendCallback.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\n/**\r\n * Represents a Fitness Equipment sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to fitness equipment.\r\n *\r\n * @category Sensors\r\n */\r\nexport class FitnessEquipmentSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Fitness Equipment sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 0x11;\r\n\r\n    /**\r\n     * The current state of the Fitness Equipment sensor.\r\n     * @private\r\n     * @type {FitnessEquipmentSensorState}\r\n     */\r\n    private state!: FitnessEquipmentSensorState;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new FitnessEquipmentSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, FitnessEquipmentSensor.deviceType, 0, 255, 8192);\r\n        this.state = new FitnessEquipmentSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n\r\n    /**\r\n     * Sends user configuration data to the sensor internally.\r\n     *\r\n     * @private\r\n     * @param {number} [userWeight] - The user's weight in kilograms.\r\n     * @param {number} [bikeWeight] - The weight of the bike in kilograms.\r\n     * @param {number} [wheelDiameter] - The diameter of the wheel in meters.\r\n     * @param {number} [gearRatio] - The gear ratio.\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     */\r\n    private async setUserConfigurationInternal(userWeight?: number, bikeWeight?: number, wheelDiameter?: number, gearRatio?: number, cbk?: SendCallback): Promise<void> {\r\n        const m = userWeight == null ? 0xffff : Math.max(0, Math.min(65534, Math.round(userWeight * 100)));\r\n        const df = wheelDiameter == null ? 0xff : Math.round(wheelDiameter * 10) % 10;\r\n        const mb = bikeWeight == null ? 0xfff : Math.max(0, Math.min(1000, Math.round(bikeWeight * 20)));\r\n        const d = wheelDiameter == null ? 0xff : Math.max(0, Math.min(254, Math.round(wheelDiameter)));\r\n        const gr = gearRatio == null ? 0x00 : Math.max(1, Math.min(255, Math.round(gearRatio / 0.03)));\r\n        const payload = [0x37, m & 0xff, (m >> 8) & 0xff, 0xff, (df & 0xf) | ((mb & 0xf) << 4), (mb >> 4) & 0xf, d & 0xff, gr & 0xff];\r\n        const msg = Messages.acknowledgedData(this.channel!, payload);\r\n        await this.send(msg, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sets the user configuration for the sensor.\r\n     *\r\n     * @public\r\n     * @param {number|SendCallback} [userWeightOrCallback] - The user's weight in kilograms or a callback function.\r\n     * @param {number} [bikeWeight] - The weight of the bike in kilograms.\r\n     * @param {number} [wheelDiameter] - The diameter of the wheel in meters.\r\n     * @param {number} [gearRatio] - The gear ratio.\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setUserConfiguration(70, 10, 0.7, 3.5, callbackFunction);\r\n     */\r\n    public async setUserConfiguration(userWeightOrCallback?: number | SendCallback, bikeWeight?: number, wheelDiameter?: number, gearRatio?: number, cbk?: SendCallback): Promise<void> {\r\n        if (typeof userWeightOrCallback === \"function\") {\r\n            await this.setUserConfigurationInternal(undefined, undefined, undefined, undefined, userWeightOrCallback);\r\n        } else if (typeof bikeWeight === \"function\") {\r\n            await this.setUserConfigurationInternal(userWeightOrCallback, undefined, undefined, undefined, bikeWeight);\r\n        } else if (typeof wheelDiameter === \"function\") {\r\n            await this.setUserConfigurationInternal(userWeightOrCallback, bikeWeight, undefined, undefined, wheelDiameter);\r\n        } else if (typeof gearRatio === \"function\") {\r\n            await this.setUserConfigurationInternal(userWeightOrCallback, bikeWeight, wheelDiameter, undefined, gearRatio);\r\n        } else {\r\n            await this.setUserConfigurationInternal(userWeightOrCallback, bikeWeight, wheelDiameter, gearRatio, cbk);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the basic resistance level on the fitness equipment.\r\n     *\r\n     * @public\r\n     * @param {number} resistance - The resistance level to set (0 to 100).\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setBasicResistance(50, callbackFunction);\r\n     */\r\n    public async setBasicResistance(resistance: number, cbk?: SendCallback): Promise<void> {\r\n        const res = Math.max(0, Math.min(200, Math.round(resistance * 2)));\r\n        const payload = [0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, res & 0xff];\r\n        const msg = Messages.acknowledgedData(this.channel!, payload);\r\n        await this.send(msg, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sets the target power level on the fitness equipment.\r\n     *\r\n     * @public\r\n     * @param {number} power - The target power level in watts.\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setTargetPower(250, callbackFunction);\r\n     */\r\n    public async setTargetPower(power: number, cbk?: SendCallback): Promise<void> {\r\n        const p = Math.max(0, Math.min(4000, Math.round(power * 4)));\r\n        const payload = [0x31, 0xff, 0xff, 0xff, 0xff, 0xff, p & 0xff, (p >> 8) & 0xff];\r\n        const msg = Messages.acknowledgedData(this.channel!, payload);\r\n        await this.send(msg, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sends wind resistance data to the sensor internally.\r\n     *\r\n     * @private\r\n     * @param {number} [windCoeff] - The wind resistance coefficient.\r\n     * @param {number} [windSpeed] - The wind speed in km/h.\r\n     * @param {number} [draftFactor] - The drafting factor (0 to 1).\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     */\r\n    private async setWindResistanceInternal(windCoeff?: number, windSpeed?: number, draftFactor?: number, cbk?: SendCallback): Promise<void> {\r\n        const wc = windCoeff == null ? 0xff : Math.max(0, Math.min(186, Math.round(windCoeff * 100)));\r\n        const ws = windSpeed == null ? 0xff : Math.max(0, Math.min(254, Math.round(windSpeed + 127)));\r\n        const df = draftFactor == null ? 0xff : Math.max(0, Math.min(100, Math.round(draftFactor * 100)));\r\n        const payload = [0x32, 0xff, 0xff, 0xff, 0xff, wc & 0xff, ws & 0xff, df & 0xff];\r\n        const msg = Messages.acknowledgedData(this.channel!, payload);\r\n        await this.send(msg, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sets the wind resistance on the fitness equipment.\r\n     *\r\n     * @public\r\n     * @param {number|SendCallback} [windCoeffOrCallback] - The wind resistance coefficient or a callback function.\r\n     * @param {number} [windSpeed] - The wind speed in km/h.\r\n     * @param {number} [draftFactor] - The drafting factor (0 to 1).\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setWindResistance(0.5, 20, 0.1, callbackFunction);\r\n     */\r\n    public async setWindResistance(windCoeffOrCallback?: number | SendCallback, windSpeed?: number, draftFactor?: number, cbk?: SendCallback): Promise<void> {\r\n        if (typeof windCoeffOrCallback === \"function\") {\r\n            await this.setWindResistanceInternal(undefined, undefined, undefined, windCoeffOrCallback);\r\n        } else if (typeof windSpeed === \"function\") {\r\n            await this.setWindResistanceInternal(windCoeffOrCallback, undefined, undefined, windSpeed);\r\n        } else if (typeof draftFactor === \"function\") {\r\n            await this.setWindResistanceInternal(windCoeffOrCallback, windSpeed, undefined, draftFactor);\r\n        } else {\r\n            await this.setWindResistanceInternal(windCoeffOrCallback, windSpeed, draftFactor, cbk);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends track resistance data to the sensor internally.\r\n     *\r\n     * @private\r\n     * @param {number} [slope] - The track slope percentage.\r\n     * @param {number} [rollingResistanceCoeff] - The rolling resistance coefficient.\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     */\r\n    private async setTrackResistanceInternal(slope?: number, rollingResistanceCoeff?: number, cbk?: SendCallback): Promise<void> {\r\n        const s = slope == null ? 0xffff : Math.max(0, Math.min(40000, Math.round((slope + 200) * 100)));\r\n        const rr = rollingResistanceCoeff == null ? 0xff : Math.max(0, Math.min(254, Math.round(rollingResistanceCoeff * 20000)));\r\n        const payload = [0x33, 0xff, 0xff, 0xff, 0xff, s & 0xff, (s >> 8) & 0xff, rr & 0xff];\r\n        const msg = Messages.acknowledgedData(this.channel!, payload);\r\n        await this.send(msg, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sets the track resistance on the fitness equipment.\r\n     *\r\n     * @public\r\n     * @param {number|SendCallback} [slopeOrCallback] - The track slope percentage or a callback function.\r\n     * @param {number} [rollingResistanceCoeff] - The rolling resistance coefficient.\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setTrackResistance(5, 0.005, callbackFunction);\r\n     */\r\n    public async setTrackResistance(slopeOrCallback?: number | SendCallback, rollingResistanceCoeff?: number, cbk?: SendCallback): Promise<void> {\r\n        if (typeof slopeOrCallback === \"function\") {\r\n            await this.setTrackResistanceInternal(undefined, undefined, slopeOrCallback);\r\n        } else if (typeof rollingResistanceCoeff === \"function\") {\r\n            await this.setTrackResistanceInternal(slopeOrCallback, undefined, rollingResistanceCoeff);\r\n        } else {\r\n            await this.setTrackResistanceInternal(slopeOrCallback, rollingResistanceCoeff, cbk);\r\n        }\r\n    }\r\n}\r\n","import { updateState } from \"./fitnessEquipmentUtils.js\";\r\nimport { FitnessEquipmentScanState } from \"./fitnessEquipmentScanState.js\";\r\nimport { FitnessEquipmentSensor } from \"./fitnessEquipmentSensor.js\";\r\nimport { AntPlusScanner } from \"../antPlusScanner.js\";\r\n\r\n/**\r\n * Represents a scanner for Fitness Equipment sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple fitness equipment sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class FitnessEquipmentScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Fitness Equipment sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Fitness Equipment sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return FitnessEquipmentSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Fitness Equipment sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: FitnessEquipmentScanState }}\r\n     */\r\n    private states: { [id: number]: FitnessEquipmentScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new FitnessEquipmentScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { Messages } from \"../../utils/messages.js\";\r\nimport { MuscleOxygenSensorState } from \"./muscleOxygenSensorState.js\";\r\nimport { MuscleOxygenScanState } from \"./muscleOxygenScanState.js\";\r\nimport { MuscleOxygenSensor } from \"./muscleOxygenSensor.js\";\r\nimport { MuscleOxygenScanner } from \"./muscleOxygenScanner.js\";\r\n\r\n/**\r\n * Updates the state of a Muscle Oxygen sensor or scanner based on the incoming data.\r\n * Decodes various pages of data to update the state, including event counts, sensor capabilities,\r\n * measurement intervals, total hemoglobin concentration, and battery status.\r\n *\r\n * @param {MuscleOxygenSensor | MuscleOxygenScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {MuscleOxygenSensorState | MuscleOxygenScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n *\r\n * @example\r\n * const sensor = new MuscleOxygenSensor();\r\n * const state = new MuscleOxygenSensorState(12345);\r\n * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n * updateState(sensor, state, dataBuffer);\r\n */\r\nexport function updateState(sensor: MuscleOxygenSensor | MuscleOxygenScanner, state: MuscleOxygenSensorState | MuscleOxygenScanState, data: DataView) {\r\n    const oldEventCount = state._EventCount || 0;\r\n    const page = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n\r\n    switch (page) {\r\n        case 0x01: {\r\n            let eventCount = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 1);\r\n            const notifications = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const capabilities = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 3, true);\r\n            const total = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true) & 0xfff;\r\n            const previous = (data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 5, true) >> 4) & 0x3ff;\r\n            const current = (data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true) >> 6) & 0x3ff;\r\n\r\n            if (eventCount !== oldEventCount) {\r\n                state._EventCount = eventCount;\r\n                if (oldEventCount > eventCount) {\r\n                    // Hit rollover value\r\n                    eventCount += 255;\r\n                }\r\n            }\r\n\r\n            state.UTCTimeRequired = (notifications & 0x01) === 0x01;\r\n            state.SupportANTFS = (capabilities & 0x01) === 0x01;\r\n\r\n            switch ((capabilities >> 1) & 0x7) {\r\n                case 1:\r\n                    state.MeasurementInterval = 0.25;\r\n                    break;\r\n                case 2:\r\n                    state.MeasurementInterval = 0.5;\r\n                    break;\r\n                case 3:\r\n                    state.MeasurementInterval = 1;\r\n                    break;\r\n                case 4:\r\n                    state.MeasurementInterval = 2;\r\n                    break;\r\n                default:\r\n                    delete state.MeasurementInterval;\r\n            }\r\n\r\n            switch (total) {\r\n                case 0xffe:\r\n                    state.TotalHemoglobinConcentration = \"AmbientLightTooHigh\";\r\n                    break;\r\n                case 0xfff:\r\n                    state.TotalHemoglobinConcentration = \"Invalid\";\r\n                    break;\r\n                default:\r\n                    state.TotalHemoglobinConcentration = total;\r\n            }\r\n\r\n            switch (previous) {\r\n                case 0x3fe:\r\n                    state.PreviousSaturatedHemoglobinPercentage = \"AmbientLightTooHigh\";\r\n                    break;\r\n                case 0x3ff:\r\n                    state.PreviousSaturatedHemoglobinPercentage = \"Invalid\";\r\n                    break;\r\n                default:\r\n                    state.PreviousSaturatedHemoglobinPercentage = previous;\r\n            }\r\n\r\n            switch (current) {\r\n                case 0x3fe:\r\n                    state.CurrentSaturatedHemoglobinPercentage = \"AmbientLightTooHigh\";\r\n                    break;\r\n                case 0x3ff:\r\n                    state.CurrentSaturatedHemoglobinPercentage = \"Invalid\";\r\n                    break;\r\n                default:\r\n                    state.CurrentSaturatedHemoglobinPercentage = current;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x50: {\r\n            state.HwVersion = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            state.ManId = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n            state.ModelNum = data.getUint16(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n            break;\r\n        }\r\n        case 0x51: {\r\n            const swRevSup = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const swRevMain = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 3);\r\n            const serial = data.getUint32(Messages.BUFFER_INDEX_MSG_DATA + 4, true);\r\n\r\n            state.SwVersion = swRevMain;\r\n\r\n            if (swRevSup !== 0xff) {\r\n                state.SwVersion += swRevSup / 1000;\r\n            }\r\n\r\n            if (serial !== 0xffffffff) {\r\n                state.SerialNumber = serial;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case 0x52: {\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            const batteryId = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n            const operatingTime = data.getUint32(Messages.BUFFER_INDEX_MSG_DATA + 3, true) & 0xffffff;\r\n            const batteryFrac = data.getUint32(Messages.BUFFER_INDEX_MSG_DATA + 6, true);\r\n            const batteryStatus = data.getUint32(Messages.BUFFER_INDEX_MSG_DATA + 7, true);\r\n\r\n            state.OperatingTime = operatingTime * ((batteryStatus & 0x80) === 0x80 ? 2 : 16);\r\n            state.BatteryVoltage = (batteryStatus & 0x0f) + batteryFrac / 256;\r\n            const batteryFlags = (batteryStatus & 0x70) >>> 4;\r\n            state.BatteryStatusBit = batteryFlags;\r\n            switch (batteryFlags) {\r\n                case 1:\r\n                    state.BatteryStatus = \"New\";\r\n                    break;\r\n                case 2:\r\n                    state.BatteryStatus = \"Good\";\r\n                    break;\r\n                case 3:\r\n                    state.BatteryStatus = \"Ok\";\r\n                    break;\r\n                case 4:\r\n                    state.BatteryStatus = \"Low\";\r\n                    break;\r\n                case 5:\r\n                    state.BatteryStatus = \"Critical\";\r\n                    break;\r\n                default:\r\n                    state.BatteryVoltage = undefined;\r\n                    state.BatteryStatus = \"Invalid\";\r\n                    break;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n            return;\r\n    }\r\n    if (page !== 0x01 || state._EventCount !== oldEventCount) {\r\n        sensor.emit(\"oxygenData\", state);\r\n    }\r\n}\r\n","/**\r\n * Represents the state of a Muscle Oxygen sensor.\r\n * This class holds the data fields associated with the state of a Muscle Oxygen sensor, including\r\n * event count, device details, measurement data, and battery status.\r\n */\r\nexport class MuscleOxygenSensorState {\r\n    /**\r\n     * Creates an instance of the MuscleOxygenSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @example\r\n     * const sensorState = new MuscleOxygenSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The count of events detected by the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    _EventCount?: number;\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * Indicates whether UTC time is required by the sensor.\r\n     * @type {boolean | undefined}\r\n     */\r\n    UTCTimeRequired?: boolean;\r\n\r\n    /**\r\n     * Indicates whether ANT-FS is supported by the sensor.\r\n     * @type {boolean | undefined}\r\n     */\r\n    SupportANTFS?: boolean;\r\n\r\n    /**\r\n     * The measurement interval in seconds.\r\n     * Possible values: 0.25, 0.5, 1, or 2 seconds.\r\n     * @type {0.25 | 0.5 | 1 | 2 | undefined}\r\n     */\r\n    MeasurementInterval?: 0.25 | 0.5 | 1 | 2;\r\n\r\n    /**\r\n     * The total hemoglobin concentration.\r\n     * Can be a numeric value, \"AmbientLightTooHigh\", or \"Invalid\".\r\n     * @type {number | \"AmbientLightTooHigh\" | \"Invalid\" | undefined}\r\n     */\r\n    TotalHemoglobinConcentration?: number | \"AmbientLightTooHigh\" | \"Invalid\";\r\n\r\n    /**\r\n     * The percentage of saturated hemoglobin from the previous measurement.\r\n     * Can be a numeric value, \"AmbientLightTooHigh\", or \"Invalid\".\r\n     * @type {number | \"AmbientLightTooHigh\" | \"Invalid\" | undefined}\r\n     */\r\n    PreviousSaturatedHemoglobinPercentage?: number | \"AmbientLightTooHigh\" | \"Invalid\";\r\n\r\n    /**\r\n     * The percentage of saturated hemoglobin from the current measurement.\r\n     * Can be a numeric value, \"AmbientLightTooHigh\", or \"Invalid\".\r\n     * @type {number | \"AmbientLightTooHigh\" | \"Invalid\" | undefined}\r\n     */\r\n    CurrentSaturatedHemoglobinPercentage?: number | \"AmbientLightTooHigh\" | \"Invalid\";\r\n\r\n    /**\r\n     * The hardware version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    HwVersion?: number;\r\n\r\n    /**\r\n     * The manufacturer ID of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ManId?: number;\r\n\r\n    /**\r\n     * The model number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    ModelNum?: number;\r\n\r\n    /**\r\n     * The software version of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SwVersion?: number;\r\n\r\n    /**\r\n     * The serial number of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    SerialNumber?: number;\r\n\r\n    /**\r\n     * The cumulative operating time of the sensor in seconds.\r\n     * @type {number | undefined}\r\n     */\r\n    OperatingTime?: number;\r\n\r\n    /**\r\n     * The battery voltage of the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    BatteryVoltage?: number;\r\n\r\n    /**\r\n     * The battery status of the sensor.\r\n     * Can be \"New\", \"Good\", \"Ok\", \"Low\", \"Critical\", or \"Invalid\".\r\n     * @type {\"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\" | undefined}\r\n     */\r\n    BatteryStatus?: \"New\" | \"Good\" | \"Ok\" | \"Low\" | \"Critical\" | \"Invalid\";\r\n\r\n    /**\r\n     * The battery status bit of the sensor.\r\n     */\r\n    BatteryStatusBit?: number;\r\n}\r\n","import { MuscleOxygenSensorState } from \"./muscleOxygenSensorState.js\";\r\n\r\n/**\r\n * Represents the state of a Muscle Oxygen sensor during scanning.\r\n * Extends the MuscleOxygenSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class MuscleOxygenScanState extends MuscleOxygenSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value for the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#521_tab\r\n * Spec sheet: https://www.thisisant.com/resources/bicycle-power/\r\n */\r\n\r\nimport { updateState } from \"./muscleOxygenUtils.js\";\r\nimport { MuscleOxygenSensorState } from \"./muscleOxygenSensorState.js\";\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\nimport { SendCallback } from \"../../types/sendCallback.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\n/**\r\n * Represents a Muscle Oxygen sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to muscle oxygen measurements.\r\n *\r\n * @category Sensors\r\n */\r\nexport class MuscleOxygenSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Muscle Oxygen sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 0x1f;\r\n\r\n    /**\r\n     * The current state of the Muscle Oxygen sensor.\r\n     * @private\r\n     * @type {MuscleOxygenSensorState}\r\n     */\r\n    private state!: MuscleOxygenSensorState;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new MuscleOxygenSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, MuscleOxygenSensor.deviceType, 0, 255, 8192);\r\n        this.state = new MuscleOxygenSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView) {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n\r\n    /**\r\n     * Sends a time-based command to the sensor.\r\n     *\r\n     * @private\r\n     * @param {number} cmd - The command code to be sent.\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor._sendTimeCmd(0x00, callbackFunction);\r\n     */\r\n    private async _sendTimeCmd(cmd: number, cbk?: SendCallback): Promise<void> {\r\n        const now = new Date();\r\n        const utc = Math.round((now.getTime() - Date.UTC(1989, 11, 31, 0, 0, 0, 0)) / 1000);\r\n        const offset = -Math.round(now.getTimezoneOffset() / 15);\r\n        const payload = [0x10, cmd & 0xff, 0xff, offset & 0xff, (utc >> 0) & 0xff, (utc >> 8) & 0xff, (utc >> 16) & 0xff, (utc >> 24) & 0xff];\r\n        const msg = Messages.acknowledgedData(this.channel!, payload);\r\n        await this.send(msg, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sets the UTC time on the sensor.\r\n     *\r\n     * @public\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setUTCTime(callbackFunction);\r\n     */\r\n    public async setUTCTime(cbk?: SendCallback): Promise<void> {\r\n        await this._sendTimeCmd(0x00, cbk);\r\n    }\r\n\r\n    /**\r\n     * Starts a new session on the sensor.\r\n     *\r\n     * @public\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.startSession(callbackFunction);\r\n     */\r\n    public async startSession(cbk?: SendCallback): Promise<void> {\r\n        await this._sendTimeCmd(0x01, cbk);\r\n    }\r\n\r\n    /**\r\n     * Stops the current session on the sensor.\r\n     *\r\n     * @public\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.stopSession(callbackFunction);\r\n     */\r\n    public async stopSession(cbk?: SendCallback): Promise<void> {\r\n        await this._sendTimeCmd(0x02, cbk);\r\n    }\r\n\r\n    /**\r\n     * Sets a lap marker on the sensor.\r\n     *\r\n     * @public\r\n     * @param {SendCallback} [cbk] - Optional callback function to handle the send response.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * sensor.setLap(callbackFunction);\r\n     */\r\n    public async setLap(cbk?: SendCallback): Promise<void> {\r\n        await this._sendTimeCmd(0x03, cbk);\r\n    }\r\n}\r\n","import { updateState } from \"./muscleOxygenUtils.js\";\r\nimport { MuscleOxygenScanState } from \"./muscleOxygenScanState.js\";\r\nimport { MuscleOxygenSensor } from \"./muscleOxygenSensor.js\";\r\nimport { AntPlusScanner } from \"../antPlusScanner.js\";\r\n\r\n/**\r\n * Represents a scanner for Muscle Oxygen sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple Muscle Oxygen sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class MuscleOxygenScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Muscle Oxygen sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Muscle Oxygen sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return MuscleOxygenSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Muscle Oxygen sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: MuscleOxygenScanState }}\r\n     */\r\n    private states: { [id: number]: MuscleOxygenScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new MuscleOxygenScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n","import { EnvironmentScanner } from \"./environmentScanner.js\";\r\nimport { EnvironmentScanState } from \"./environmentScanState.js\";\r\nimport { EnvironmentSensor } from \"./environmentSensor.js\";\r\nimport { EnvironmentSensorState } from \"./environmentSensorState.js\";\r\nimport { Messages } from \"../../utils/messages.js\";\r\n\r\n/**\r\n * Updates the state of an Environment sensor or scanner based on incoming data.\r\n * Decodes the data buffer and updates the sensor state accordingly.\r\n *\r\n * @param {EnvironmentSensor | EnvironmentScanner} sensor - The sensor or scanner instance emitting the data.\r\n * @param {EnvironmentSensorState | EnvironmentScanState} state - The current state of the sensor or scanner.\r\n * @param {DataView} data - The raw data buffer received from the sensor.\r\n * @returns {void}\r\n */\r\nexport function updateState(sensor: EnvironmentSensor | EnvironmentScanner, state: EnvironmentSensorState | EnvironmentScanState, data: DataView): void {\r\n    const page = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA);\r\n\r\n    if (page === 1) {\r\n        state.EventCount = data.getUint8(Messages.BUFFER_INDEX_MSG_DATA + 2);\r\n        state.Temperature = data.getInt16(Messages.BUFFER_INDEX_MSG_DATA + 6, true) / 100; // true for little-endian\r\n    }\r\n\r\n    sensor.emit(\"envdata\", state);\r\n    sensor.emit(\"envData\", state);\r\n}\r\n","/**\r\n * Represents the state of an Environment Sensor.\r\n * This class holds the data fields associated with the state of an environment sensor,\r\n * such as the event count and temperature.\r\n */\r\nexport class EnvironmentSensorState {\r\n    /**\r\n     * Creates an instance of the EnvironmentSensorState.\r\n     *\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     *\r\n     * @example\r\n     * const sensorState = new EnvironmentSensorState(12345);\r\n     */\r\n    constructor(deviceId: number) {\r\n        this.DeviceId = deviceId;\r\n    }\r\n\r\n    /**\r\n     * The unique identifier of the sensor device.\r\n     * @type {number}\r\n     */\r\n    DeviceId: number;\r\n\r\n    /**\r\n     * The event count recorded by the sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    EventCount: number | undefined;\r\n\r\n    /**\r\n     * The temperature measured by the sensor, in degrees Celsius.\r\n     * @type {number | undefined}\r\n     */\r\n    Temperature: number | undefined;\r\n}\r\n","import { EnvironmentSensorState } from \"./environmentSensorState.js\";\r\n\r\n/**\r\n * Represents the state of an Environment Sensor during scanning.\r\n * Extends the EnvironmentSensorState to include additional fields specific to scanning,\r\n * such as RSSI (Received Signal Strength Indicator) and signal threshold.\r\n */\r\nexport class EnvironmentScanState extends EnvironmentSensorState {\r\n    /**\r\n     * The received signal strength indicator (RSSI) of the sensor signal.\r\n     * Indicates the strength of the received signal from the environment sensor.\r\n     * @type {number | undefined}\r\n     */\r\n    Rssi: number | undefined;\r\n\r\n    /**\r\n     * The signal threshold value for the sensor.\r\n     * Represents the minimum signal strength required for a reliable connection.\r\n     * @type {number | undefined}\r\n     */\r\n    Threshold: number | undefined;\r\n}\r\n","/*\r\n * ANT+ profile: https://www.thisisant.com/developer/ant-plus/device-profiles/#524_tab\r\n * Spec sheet: https://www.thisisant.com/resources/environment/\r\n */\r\n\r\nimport { updateState } from \"./environmentUtils.js\";\r\nimport { EnvironmentSensorState } from \"./environmentSensorState.js\";\r\nimport { AntPlusSensor } from \"../antPlusSensor.js\";\r\n\r\n/**\r\n * Represents an Environment sensor.\r\n * This class extends the AntPlusSensor class to handle specific data related to environmental monitoring.\r\n *\r\n * @category Sensors\r\n */\r\nexport class EnvironmentSensor extends AntPlusSensor {\r\n    /**\r\n     * The device type code for Environment sensors.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    static deviceType: number = 25;\r\n\r\n    /**\r\n     * Attaches the sensor to a specified ANT+ channel and initializes its state.\r\n     *\r\n     * @public\r\n     * @param {number} channel - The ANT+ channel number used for communication with the sensor.\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const sensor = new EnvironmentSensor();\r\n     * sensor.attach(1, 12345); // Attaches to channel 1 with device ID 12345\r\n     */\r\n    public async attach(channel: number, deviceId: number): Promise<void> {\r\n        await super.attachSensor(channel, \"receive\", deviceId, EnvironmentSensor.deviceType, 0, 255, 8192);\r\n        this.state = new EnvironmentSensorState(deviceId);\r\n    }\r\n\r\n    /**\r\n     * The current state of the Environment sensor.\r\n     * @private\r\n     * @type {EnvironmentSensorState}\r\n     */\r\n    private state!: EnvironmentSensorState;\r\n\r\n    /**\r\n     * Updates the state of the sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // assume this function gets data from a sensor\r\n     * sensor.updateState(12345, dataBuffer);\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        this.state.DeviceId = deviceId;\r\n        updateState(this, this.state, data);\r\n    }\r\n}\r\n","import { updateState } from \"./environmentUtils.js\";\r\nimport { EnvironmentScanState } from \"./environmentScanState.js\";\r\nimport { EnvironmentSensor } from \"./environmentSensor.js\";\r\nimport { AntPlusScanner } from \"../antPlusScanner.js\";\r\n\r\n/**\r\n * Represents a scanner for Environment sensors.\r\n * Extends the AntPlusScanner class to handle scanning and state updates for multiple environment sensors.\r\n *\r\n * @category Sensors\r\n */\r\nexport class EnvironmentScanner extends AntPlusScanner {\r\n    /**\r\n     * Returns the device type code for Environment sensors.\r\n     *\r\n     * @protected\r\n     * @returns {number} The device type code for Environment sensors.\r\n     */\r\n    protected deviceType(): number {\r\n        return EnvironmentSensor.deviceType;\r\n    }\r\n\r\n    /**\r\n     * A dictionary to store the states of detected Environment sensors by their device ID.\r\n     * @private\r\n     * @type {{ [id: number]: EnvironmentScanState }}\r\n     */\r\n    private states: { [id: number]: EnvironmentScanState } = {};\r\n\r\n    /**\r\n     * Creates a new state entry for a sensor if it does not already exist.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.createStateIfNew(12345); // Creates a new state for device ID 12345 if it does not exist.\r\n     */\r\n    protected createStateIfNew(deviceId: number): void {\r\n        if (!this.states[deviceId]) {\r\n            this.states[deviceId] = new EnvironmentScanState(deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the RSSI (Received Signal Strength Indicator) and signal threshold for a specific sensor.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {number} rssi - The received signal strength indicator of the device.\r\n     * @param {number} threshold - The signal threshold value for the device.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * scanner.updateRssiAndThreshold(12345, -70, 30); // Updates the RSSI and threshold for device ID 12345.\r\n     */\r\n    protected updateRssiAndThreshold(deviceId: number, rssi: number, threshold: number): void {\r\n        this.states[deviceId].Rssi = rssi;\r\n        this.states[deviceId].Threshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of a sensor based on incoming data.\r\n     *\r\n     * @protected\r\n     * @param {number} deviceId - The unique identifier of the sensor device.\r\n     * @param {DataView} data - The raw data buffer received from the sensor.\r\n     * @returns {void}\r\n     *\r\n     * @example\r\n     * const dataBuffer = getDataFromSensor(); // Assume this function gets data from a sensor\r\n     * scanner.updateState(12345, dataBuffer); // Updates the state for device ID 12345.\r\n     */\r\n    protected updateState(deviceId: number, data: DataView): void {\r\n        updateState(this, this.states[deviceId], data);\r\n    }\r\n}\r\n"],"names":["Constants","MESSAGE_RF","MESSAGE_TX_SYNC","DEFAULT_NETWORK_NUMBER","MESSAGE_CHANNEL_UNASSIGN","MESSAGE_CHANNEL_ASSIGN","MESSAGE_CHANNEL_ID","MESSAGE_CHANNEL_PERIOD","MESSAGE_CHANNEL_SEARCH_TIMEOUT","MESSAGE_CHANNEL_FREQUENCY","MESSAGE_CHANNEL_TX_POWER","MESSAGE_NETWORK_KEY","MESSAGE_TX_POWER","MESSAGE_PROXIMITY_SEARCH","MESSAGE_ENABLE_RX_EXT","MESSAGE_LIB_CONFIG","MESSAGE_CHANNEL_OPEN_RX_SCAN","MESSAGE_STARTUP","MESSAGE_SYSTEM_RESET","MESSAGE_CHANNEL_OPEN","MESSAGE_CHANNEL_CLOSE","MESSAGE_CHANNEL_REQUEST","MESSAGE_CHANNEL_BROADCAST_DATA","MESSAGE_CHANNEL_ACKNOWLEDGED_DATA","MESSAGE_CHANNEL_BURST_DATA","MESSAGE_CHANNEL_EVENT","MESSAGE_CHANNEL_STATUS","MESSAGE_VERSION","MESSAGE_CAPABILITIES","MESSAGE_SERIAL_NUMBER","CHANNEL_TYPE_TWOWAY_RECEIVE","CHANNEL_TYPE_TWOWAY_TRANSMIT","CHANNEL_TYPE_SHARED_RECEIVE","CHANNEL_TYPE_SHARED_TRANSMIT","CHANNEL_TYPE_ONEWAY_RECEIVE","CHANNEL_TYPE_ONEWAY_TRANSMIT","RADIO_TX_POWER_MINUS20DB","RADIO_TX_POWER_MINUS10DB","RADIO_TX_POWER_0DB","RADIO_TX_POWER_PLUS4DB","RESPONSE_NO_ERROR","EVENT_RX_SEARCH_TIMEOUT","EVENT_RX_FAIL","EVENT_TX","EVENT_TRANSFER_RX_FAILED","EVENT_TRANSFER_TX_COMPLETED","EVENT_TRANSFER_TX_FAILED","EVENT_CHANNEL_CLOSED","EVENT_RX_FAIL_GO_TO_SEARCH","EVENT_CHANNEL_COLLISION","EVENT_TRANSFER_TX_START","CHANNEL_IN_WRONG_STATE","CHANNEL_NOT_OPENED","CHANNEL_ID_NOT_SET","CLOSE_ALL_CHANNELS","TRANSFER_IN_PROGRESS","TRANSFER_SEQUENCE_NUMBER_ERROR","TRANSFER_IN_ERROR","MESSAGE_SIZE_EXCEEDS_LIMIT","INVALID_MESSAGE","INVALID_NETWORK_NUMBER","INVALID_LIST_ID","INVALID_SCAN_TX_CHANNEL","INVALID_PARAMETER_PROVIDED","EVENT_QUEUE_OVERFLOW","USB_STRING_WRITE_FAIL","CHANNEL_STATE_UNASSIGNED","CHANNEL_STATE_ASSIGNED","CHANNEL_STATE_SEARCHING","CHANNEL_STATE_TRACKING","CAPABILITIES_NO_RECEIVE_CHANNELS","CAPABILITIES_NO_TRANSMIT_CHANNELS","CAPABILITIES_NO_RECEIVE_MESSAGES","CAPABILITIES_NO_TRANSMIT_MESSAGES","CAPABILITIES_NO_ACKNOWLEDGED_MESSAGES","CAPABILITIES_NO_BURST_MESSAGES","CAPABILITIES_NETWORK_ENABLED","CAPABILITIES_SERIAL_NUMBER_ENABLED","CAPABILITIES_PER_CHANNEL_TX_POWER_ENABLED","CAPABILITIES_LOW_PRIORITY_SEARCH_ENABLED","CAPABILITIES_SCRIPT_ENABLED","CAPABILITIES_SEARCH_LIST_ENABLED","CAPABILITIES_LED_ENABLED","CAPABILITIES_EXT_MESSAGE_ENABLED","CAPABILITIES_SCAN_MODE_ENABLED","CAPABILITIES_PROX_SEARCH_ENABLED","CAPABILITIES_EXT_ASSIGN_ENABLED","CAPABILITIES_FS_ANTFS_ENABLED","TIMEOUT_NEVER","Messages","resetSystem","payload","push","this","buildMessage","requestMessage","channel","messageId","concat","intToLEHexArray","setNetworkKey","assignChannel","type","Error","setDevice","deviceId","deviceType","transmissionType","searchChannel","timeout","setPeriod","period","setFrequency","frequency","setRxExt","libConfig","how","openRxScan","openChannel","closeChannel","unassignChannel","acknowledgedData","broadcastData","message","length","forEach","byte","getChecksum","Uint8Array","int","numBytes","a","hexString","decimalToHex","i","parseInt","substr","d","numDigits","hex","Number","toString","checksum","BUFFER_INDEX_MSG_LEN","BUFFER_INDEX_MSG_TYPE","BUFFER_INDEX_CHANNEL_NUM","BUFFER_INDEX_MSG_DATA","BUFFER_INDEX_EXT_MSG_BEGIN","NodeUSBDriver","EventEmitter","constructor","idVendor","idProduct","debugOptions","super","detachedKernelDriver","usedChannels","attachedSensors","maxChannels","_canScan","throwLibUSBException","setMaxListeners","usb","setDebugLevel","usbDebugLevel","canAttach","Promise","resolve","canScan","open","devices","getDevices","device","shift","iface","interfaces","isKernelDriverActive","detachKernelDriver","_a","claim","error","errno","LIBUSB_ERROR_ACCESS","LIBUSB_ERROR_NO_DEVICE","LIBUSB_ERROR_BUSY","console","close","undefined","deviceInUse","inEndpoint","endpoints","on","data","onData","catch","err","startPoll","outEndpoint","reset","detachAll","stopPoll","release","attachKernelDriver","_b","emit","devIdx","indexOf","splice","listenerCount","read","dataView","DataView","buffer","getUint8","write","reject","transfer","Buffer","from","attach","sensor","forScan","detach","idx","isPresent","isScanning","getDeviceList","filter","deviceDescriptor","copy","leftover","concatUint8Arrays","len","beginBlock","slice","endBlock","readData","arr1","arr2","result","set","GarminStick2","GarminStick3","supportHardware","vendorId","productId","WebUSBDriver","abortController","AbortController","signal","navigator","requestDevice","filters","configuration","claimInterface","interfaceNumber","alternate","find","e","direction","readLoop","log","aborted","transferIn","endpointNumber","packetSize","cancelReadLoop","abort","transferOut","WebUsbStick","nextTick","fn","process","setImmediate","setTimeout","BaseSensor","stick","messageQueue","handleEventMessages","scan","onStatus","status","__awaiter","msg","code","mc","cbk","statusCbk","errorMessage","attachSensor","Array","map","join","decodeDataCbk","send","PageState","updateState","state","page","pageNum","pageState","INIT_PAGE","STD_PAGE","oldPage","EXT_PAGE","OperatingTime","ManId","SerialNumber","DeviceId","getUint16","HwVersion","SwVersion","ModelNum","PreviousBeat","IntervalAverage","IntervalMax","SessionAverage","SupportedFeatures","EnabledFeatures","batteryLevel","batteryFrac","batteryStatus","BatteryLevel","BatteryVoltage","batteryFlags","BatteryStatusBit","BatteryStatus","pucPayload","BeatTime","BeatCount","ComputedHeartRate","DecodeDefaultHRM","HeartRateSensorState","HeartRateScanState","AntPlusBaseSensor","_super","call","AntPlusSensor","decodeData","bind","HeartRateSensor","AntPlusScanner","byteLength","bytesArray","byteOffset","createStateIfNew","rssi","getInt8","threshold","updateRssiAndThreshold","HeartRateScanner","states","pages","Rssi","Threshold","TimeFractional","TimeInteger","DistanceInteger","DistanceFractional","SpeedInteger","SpeedFractional","StrideCount","UpdateLatency","CadenceInteger","CadenceFractional","Status","Calories","StrideSpeedDistanceSensorState","StrideSpeedDistanceScanState","StrideSpeedDistanceSensor","StrideSpeedDistanceScanner","oldCadenceTime","CadenceEventTime","oldCadenceCount","CumulativeCadenceRevolutionCount","oldSpeedTime","_c","SpeedEventTime","oldSpeedCount","_d","CumulativeSpeedRevolutionCount","cadenceTime","cadenceCount","speedEventTime","speedRevolutionCount","cadence","isNaN","CalculatedCadence","distance","wheelCircumference","CalculatedDistance","speed","CalculatedSpeed","SpeedCadenceSensorState","SpeedCadenceScanState","SpeedCadenceSensor","setWheelCircumference","SpeedCadenceScanner","Motion","SpeedSensorState","SpeedScanState","SpeedSensor","SpeedScanner","CadenceSensorState","CadenceScanState","CadenceSensor","CadenceScanner","offset","pedalPower","PedalPower","RightPedalPower","LeftPedalPower","Cadence","AccumulatedPower","Power","oldEventCount","EventCount","oldTimeStamp","TimeStamp","oldTorqueTicksStamp","TorqueTicksStamp","eventCount","slope","timeStamp","torqueTicksStamp","Slope","elapsedTime","torqueTicks","cadencePeriod","Math","round","torque","CalculatedTorque","CalculatedPower","PI","BicyclePowerSensorState","BicyclePowerScanState","BicyclePowerSensor","BicyclePowerScanner","resetState","ElapsedTime","Distance","RealSpeed","VirtualSpeed","HeartRate","HeartRateSource","CycleLength","Incline","Resistance","METs","CaloricBurnRate","_EventCount0x19","_EventCount0x1A","InstantaneousPower","AveragePower","TrainerStatus","TargetStatus","AscendedDistance","DescendedDistance","Strides","Strokes","WheelTicks","WheelPeriod","Torque","temperature","Temperature","calBF","ZeroOffset","SpinDownTime","EquipmentType","heartRate","capStateBF","oldElapsedTime","oldDistance","State","cycleLen","incline","resistance","mets","caloricbr","calories","negDistance","posDistance","flagStateBF","oldNegDistance","oldPosDistance","strides","power","oldStrides","strokes","oldStrokes","accPower","trainerStatus","oldAccPower","wheelTicks","accWheelPeriod","accTorque","oldWheelTicks","oldWheelPeriod","oldTorque","swRevSup","swRevMain","serial","getUint32","tot","chState","devId","devType","PairedDevices","id","paired","FitnessEquipmentSensorState","FitnessEquipmentScanState","FitnessEquipmentSensor","setUserConfigurationInternal","userWeight","bikeWeight","wheelDiameter","gearRatio","m","max","min","df","mb","setUserConfiguration","userWeightOrCallback","setBasicResistance","setTargetPower","p","setWindResistanceInternal","windCoeff","windSpeed","draftFactor","setWindResistance","windCoeffOrCallback","setTrackResistanceInternal","rollingResistanceCoeff","s","setTrackResistance","slopeOrCallback","FitnessEquipmentScanner","_EventCount","notifications","capabilities","total","previous","current","UTCTimeRequired","SupportANTFS","MeasurementInterval","TotalHemoglobinConcentration","PreviousSaturatedHemoglobinPercentage","CurrentSaturatedHemoglobinPercentage","operatingTime","MuscleOxygenSensorState","MuscleOxygenScanState","MuscleOxygenSensor","_sendTimeCmd","cmd","now","Date","utc","getTime","UTC","getTimezoneOffset","setUTCTime","startSession","stopSession","setLap","MuscleOxygenScanner","getInt16","EnvironmentSensorState","EnvironmentScanState","EnvironmentSensor","EnvironmentScanner"],"mappings":"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"}